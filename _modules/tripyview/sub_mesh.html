<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tripyview.sub_mesh &#8212; tripyview 0.3.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/agogo.css?v=8513425a" />
    <script src="../../_static/documentation_options.js?v=e259d695"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="header-wrapper" role="banner">
      <div class="header">
        <div class="headertitle"><a
          href="../../index.html">tripyview 0.3.0 documentation</a></div>
        <div class="rel" role="navigation" aria-label="Related">
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for tripyview.sub_mesh</h1><div class="highlight"><pre>
<span></span><span class="c1"># Patrick Scholz, 14.12.2017</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span> <span class="k">as</span> <span class="nn">clock</span>
<span class="kn">import</span> <span class="nn">numpy</span>  <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pa</span>
<span class="kn">import</span> <span class="nn">joblib</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pickle5</span> <span class="k">as</span> <span class="nn">pickle</span>
    <span class="n">foundmodpickle</span><span class="o">=</span><span class="kc">True</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="n">foundmodpickle</span><span class="o">=</span><span class="kc">False</span>
    <span class="k">pass</span>
<span class="kn">from</span>   <span class="nn">netCDF4</span> <span class="kn">import</span> <span class="n">Dataset</span>
<span class="kn">from</span> <span class="nn">.sub_mesh</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># ___INITIALISE/LOAD FESOM2.0 MESH CLASS IN MAIN PROGRAMM______________________</span>
<span class="c1">#| IMPORTANT!!!:                                                               |                                         </span>
<span class="c1">#| only when mesh is initialised with this routine, the main programm is able  |</span>
<span class="c1">#| to recognize if mesh object already exist or not and if it exist to use it  |</span>
<span class="c1">#| and not to load it again !!!                                                |</span>
<span class="c1">#|_____________________________________________________________________________|</span>
<div class="viewcode-block" id="load_mesh_fesom2">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.load_mesh_fesom2">[docs]</a>
<span class="k">def</span> <span class="nf">load_mesh_fesom2</span><span class="p">(</span>
                    <span class="n">meshpath</span><span class="p">,</span> 
                    <span class="n">abg</span>         <span class="o">=</span> <span class="p">[</span><span class="mi">50</span> <span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">]</span>        <span class="p">,</span> 
                    <span class="n">focus</span>       <span class="o">=</span> <span class="mi">0</span>                     <span class="p">,</span> 
                    <span class="n">cyclic</span>      <span class="o">=</span> <span class="mi">360</span>                   <span class="p">,</span> 
                    <span class="n">do_rot</span>      <span class="o">=</span> <span class="s1">&#39;None&#39;</span>                <span class="p">,</span> 
                    <span class="n">do_augmpbnd</span> <span class="o">=</span> <span class="kc">True</span>                  <span class="p">,</span> 
                    <span class="n">do_cavity</span>   <span class="o">=</span> <span class="kc">False</span>                 <span class="p">,</span> 
                    <span class="n">do_lsmask</span>   <span class="o">=</span> <span class="kc">True</span>                  <span class="p">,</span> 
                    <span class="n">do_lsmshp</span>   <span class="o">=</span> <span class="kc">True</span>                  <span class="p">,</span> 
                    <span class="n">do_earea</span>    <span class="o">=</span> <span class="kc">True</span>                  <span class="p">,</span> 
                    <span class="n">do_narea</span>    <span class="o">=</span> <span class="kc">True</span>                  <span class="p">,</span> 
                    <span class="n">do_eresol</span>   <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span>        <span class="p">,</span> 
                    <span class="n">do_nresol</span>   <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span><span class="s1">&#39;e_resol&#39;</span><span class="p">]</span>     <span class="p">,</span>
                    <span class="n">do_loadraw</span>  <span class="o">=</span> <span class="kc">False</span>                 <span class="p">,</span> 
                    <span class="n">do_pickle</span>   <span class="o">=</span> <span class="kc">True</span>                  <span class="p">,</span> 
                    <span class="n">do_joblib</span>   <span class="o">=</span> <span class="kc">False</span>                 <span class="p">,</span> 
                    <span class="n">do_f14cmip6</span> <span class="o">=</span> <span class="kc">False</span>                 <span class="p">,</span>
                    <span class="n">do_info</span>     <span class="o">=</span> <span class="kc">True</span>                  <span class="p">,</span> 
                    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --&gt; load FESOM2 mesh</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>

<span class="sd">        :mespath:       str, path that leads to FESOM2.0 mesh files (.out)</span>

<span class="sd">        :abg:           list, [alpha,beta,gamma], (default=[50,15,-90]) euler angles used to rotate the grids within the model</span>

<span class="sd">        :focus:         float, (default=0) sets longitude center of the mesh, lon=[-180...180], focus=180 lon=[0...360]</span>

<span class="sd">        :cyclic:        float, (default=360.0), length of cyclic domain in lon degree can be different channel configuration</span>

<span class="sd">        :do_rot:        str, (default=&#39;None&#39;) should the grid be rotated, default: &#39;None&#39; </span>
<span class="sd">                        - None, &#39;None&#39; ... no rotation is applied </span>
<span class="sd">                        - &#39;r2g&#39;        ... loaded grid is rotated and transformed to geo</span>
<span class="sd">                        - &#39;g2r&#39;        ... loaded grid is geo and transformed to rotated</span>

<span class="sd">        :do_augmpbnd:   bool, (default=True) augment periodic boundary triangles, default: True</span>

<span class="sd">        :do_cavity:     bool, (default=False) load also cavity files cavity_nlvls.out and cavity_elvls.out</span>

<span class="sd">        :do_lsmask:     bool, (default=True) </span>
<span class="sd">                        Compute land-sea mask polygon for FESOM2 mesh see mesh.lsmask, augments </span>
<span class="sd">                        its periodic boundaries see mesh.lasmask_a and computes land sea mask </span>
<span class="sd">                        patch see mesh.lsmask_p</span>

<span class="sd">        :do_lsmshp:     bool, (default=True) save land-sea mask with periodic boundnaries to shapefile         </span>

<span class="sd">        :do_earea:      bool, (default=True) compute or load from fesom.mesh.diag.nc the area of elements</span>

<span class="sd">        :do_narea:      bool, (default=True) compute or load from fesom.mesh.diag.nc the clusterarea </span>
<span class="sd">                        of vertices</span>

<span class="sd">        :do_eresol:     list([bool,str]), (default: [False,&#39;mean&#39;]) compute </span>
<span class="sd">                        resolution based on elements, str can be...</span>
<span class="sd">                        - &quot;mean&quot;: resolution based on mean element edge length, </span>
<span class="sd">                        - &quot;max&quot;: resolution based on maximum edge length, </span>
<span class="sd">                        - &quot;min&quot; resolution based on minimum edge length, </span>

<span class="sd">        :do_nresol:     list([bool,str]), (default: [False,&#39;e_resol&#39;]), compute resolution at nodes from interpolation of </span>
<span class="sd">                        resolution at elements</span>

<span class="sd">        :do_loadraw:    bool, (default=False) also load the raw vertical level information</span>
<span class="sd">                        for elements. Its the vertical level information before the exclusion</span>
<span class="sd">                        of elements that have three boundary nodes in the topography</span>

<span class="sd">        :do_pickle:     bool, (default=True) store and load mesh from .pckl binary file, </span>
<span class="sd">                        pickle5 is just supported until &lt; python3.9. If pickel library </span>
<span class="sd">                        cant be  found it switches automatic to joblib</span>

<span class="sd">        :do_joblib:     bool, (default=False) store and load mesh from .joblib binary file</span>

<span class="sd">        :do_f14cmip6:   bool, (default=False) load FESOM1.4 mesh information and squeeze it into</span>
<span class="sd">                        the framework of FESOM2. Needed here to compute AMOC on fesom1.4 </span>
<span class="sd">                        cmorized CMIP6 data.</span>

<span class="sd">        :do_info:       bool, (default=True) print progress and mesh information</span>

<span class="sd">    Returns:</span>
<span class="sd">    </span>
<span class="sd">        :mesh:          object, returns fesom_mesh object</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">pickleprotocol</span><span class="o">=</span><span class="mi">4</span>
    <span class="c1">#___________________________________________________________________________</span>
    <span class="k">if</span> <span class="n">foundmodpickle</span><span class="o">==</span><span class="kc">False</span> <span class="ow">and</span> <span class="n">do_pickle</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; warning: pickle5 module could not be found, no do_pickle </span><span class="se">\n</span><span class="s1"> is possible! Therefor switch to joblib saving/loading&#39;</span><span class="p">)</span>
        <span class="n">do_pickle</span><span class="p">,</span> <span class="n">do_joblib</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">do_joblib</span><span class="o">==</span><span class="kc">True</span> <span class="ow">and</span> <span class="n">do_pickle</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>   
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39; error: both do_joblib and do_pickle are set to True, select only one!&#39;</span><span class="p">)</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># path of mesh location</span>
    <span class="n">meshpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">meshpath</span><span class="p">)</span>
    <span class="n">meshid</span>   <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">meshpath</span><span class="p">)</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># build path for cach to store the pickle files, either in home directory or </span>
    <span class="c1"># in path given by environment variable MYPY_MESHPATH </span>
    <span class="n">cachepath</span> <span class="o">=</span> <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;MESHPATH_TRIPYVIEW&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">),</span> <span class="s2">&quot;meshcache_tripyview&quot;</span><span class="p">))</span>
    <span class="n">cachepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cachepath</span><span class="p">,</span> <span class="n">meshid</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">cachepath</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; create cache: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cachepath</span><span class="p">))</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">cachepath</span><span class="p">)</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># check if pickle file can be found somewhere either in mesh folder or in </span>
    <span class="c1"># cache folder </span>
    <span class="n">picklefname</span> <span class="o">=</span> <span class="s1">&#39;tripyview_fesom2_</span><span class="si">{}</span><span class="s1">_focus</span><span class="si">{}</span><span class="s1">.pckl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">meshid</span><span class="p">,</span><span class="n">focus</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">do_pickle</span><span class="p">:</span>
        <span class="c1"># check if mypy pickle meshfile is found in meshfolder</span>
        <span class="k">if</span>    <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meshpath</span><span class="p">,</span> <span class="n">picklefname</span><span class="p">))</span> <span class="p">):</span>
            <span class="n">loadpicklepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meshpath</span><span class="p">,</span> <span class="n">picklefname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; found *.pckl file: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">loadpicklepath</span><span class="p">)))</span>    
            
        <span class="c1"># check if mypy pickle meshfile is found in cache folder</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cachepath</span><span class="p">,</span> <span class="n">picklefname</span><span class="p">))</span> <span class="p">):</span>
            <span class="n">loadpicklepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cachepath</span><span class="p">,</span> <span class="n">picklefname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; found *.pckl file: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">loadpicklepath</span><span class="p">)))</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loadpicklepath</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; found no .pckl file in cach or mesh path&#39;</span><span class="p">)</span>
    
    <span class="n">joblibfname</span> <span class="o">=</span> <span class="s1">&#39;tripyview_fesom2_</span><span class="si">{}</span><span class="s1">_focus</span><span class="si">{}</span><span class="s1">.jlib&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">meshid</span><span class="p">,</span><span class="n">focus</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">do_joblib</span><span class="p">:</span>
        <span class="c1"># check if mypy pickle meshfile is found in meshfolder</span>
        <span class="k">if</span>    <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meshpath</span><span class="p">,</span> <span class="n">joblibfname</span><span class="p">))</span> <span class="p">):</span>
            <span class="n">loadjoblibpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meshpath</span><span class="p">,</span> <span class="n">joblibfname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; found *.jlib file: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">loadjoblibpath</span><span class="p">)))</span>    
            
        <span class="c1"># check if mypy pickle meshfile is found in cache folder</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cachepath</span><span class="p">,</span> <span class="n">joblibfname</span><span class="p">))</span> <span class="p">):</span>
            <span class="n">loadjoblibpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cachepath</span><span class="p">,</span> <span class="n">joblibfname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; found *.jlib file: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">loadjoblibpath</span><span class="p">)))</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loadjoblibpath</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; found no .jlib file in cach or mesh path&#39;</span><span class="p">)</span>            
            
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># load pickle file if it exists and load it from .pckl file, if it does not </span>
    <span class="c1"># exist create mesh object with fesom_mesh</span>
    <span class="c1"># do_pickle==True and .pckl file exists</span>
    <span class="k">if</span>  <span class="p">(</span> <span class="n">do_pickle</span> <span class="ow">and</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">loadpicklepath</span><span class="p">)</span> <span class="p">))</span> <span class="ow">or</span> \
        <span class="p">(</span> <span class="n">do_joblib</span> <span class="ow">and</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">loadjoblibpath</span><span class="p">)</span> <span class="p">)):</span> 
            
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="k">if</span>   <span class="p">(</span> <span class="n">do_pickle</span> <span class="ow">and</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">loadpicklepath</span><span class="p">)</span> <span class="p">)):</span>
            <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; load  *.pckl file: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">loadpicklepath</span><span class="p">)))</span>
            <span class="n">fid</span>  <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">loadpicklepath</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fid</span><span class="p">)</span>
            <span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">do_joblib</span> <span class="ow">and</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">loadjoblibpath</span><span class="p">)</span> <span class="p">)):</span>
            <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; load  *.jlib file: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">loadjoblibpath</span><span class="p">)))</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">loadjoblibpath</span><span class="p">)</span>
            
        <span class="n">do_pbndfind</span><span class="o">=</span><span class="kc">False</span>
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># rotate mesh if its not done in .pckle file </span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">do_rot</span> <span class="o">!=</span> <span class="n">do_rot</span><span class="p">)</span> <span class="p">:</span> 
            <span class="n">do_pbndfind</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span>   <span class="p">(</span><span class="n">do_rot</span> <span class="o">==</span> <span class="s1">&#39;r2g&#39;</span><span class="p">):</span>
                <span class="c1">#_______________________________________________________________</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">do_rot</span>          <span class="o">=</span> <span class="s1">&#39;r2g&#39;</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">n_xo</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_yo</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_y</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">n_x</span> <span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_y</span>  <span class="o">=</span> <span class="n">grid_r2g</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">abg</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_xo</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_yo</span><span class="p">)</span>
                
                <span class="c1">#_______________________________________________________________</span>
                <span class="c1"># rotate also periodic land sea mask </span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">)):</span>
                        <span class="n">auxx</span><span class="p">,</span> <span class="n">auxy</span>      <span class="o">=</span> <span class="n">grid_r2g</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">abg</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">[</span><span class="n">ii</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">[</span><span class="n">ii</span><span class="p">][:,</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">auxx</span><span class="p">,</span><span class="n">auxy</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                        <span class="k">del</span> <span class="n">auxx</span><span class="p">,</span> <span class="n">auxy</span>
                
            <span class="k">elif</span> <span class="p">(</span><span class="n">do_rot</span> <span class="o">==</span> <span class="s1">&#39;g2r&#39;</span><span class="p">):</span>
                <span class="c1">#_______________________________________________________________</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">do_rot</span>          <span class="o">=</span> <span class="s1">&#39;g2r&#39;</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">n_xo</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_yo</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_y</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">n_x</span> <span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_y</span>  <span class="o">=</span> <span class="n">grid_g2r</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">abg</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_xo</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_yo</span><span class="p">)</span>
                
                <span class="c1">#_______________________________________________________________</span>
                <span class="c1"># rotate also periodic land sea mask </span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">)):</span>
                        <span class="n">auxx</span><span class="p">,</span> <span class="n">auxy</span>      <span class="o">=</span> <span class="n">grid_g2r</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">abg</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">[</span><span class="n">ii</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">[</span><span class="n">ii</span><span class="p">][:,</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">auxx</span><span class="p">,</span><span class="n">auxy</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                        <span class="k">del</span> <span class="n">auxx</span><span class="p">,</span> <span class="n">auxy</span>
                        
            <span class="k">elif</span> <span class="p">(</span><span class="n">do_rot</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">do_rot</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">):</span>    
                <span class="n">mesh</span><span class="o">.</span><span class="n">do_rot</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This rotatio option in do_rot is not supported.&quot;</span><span class="p">)</span>
            
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># change focus </span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">focus</span> <span class="o">!=</span> <span class="n">focus</span><span class="p">):</span> 
            <span class="c1">#___________________________________________________________________</span>
            <span class="n">do_pbndfind</span>          <span class="o">=</span> <span class="kc">True</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">focus</span>           <span class="o">=</span> <span class="n">focus</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">n_xo</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_yo</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_y</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span>  <span class="n">mesh</span><span class="o">.</span><span class="n">n_y</span>  <span class="o">=</span> <span class="n">grid_focus</span><span class="p">(</span><span class="n">focus</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_xo</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_yo</span><span class="p">)</span>
        
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># rotate also periodic land sea mask </span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">)):</span>
                    <span class="n">auxx</span><span class="p">,</span> <span class="n">auxy</span>      <span class="o">=</span> <span class="n">grid_focus</span><span class="p">(</span><span class="n">focus</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">[</span><span class="n">ii</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">[</span><span class="n">ii</span><span class="p">][:,</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">auxx</span><span class="p">,</span><span class="n">auxy</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                    <span class="k">del</span> <span class="n">auxx</span><span class="p">,</span> <span class="n">auxy</span>
                        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># find periodic boundary</span>
        <span class="k">if</span> <span class="n">do_pbndfind</span><span class="p">:</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">pbnd_find</span><span class="p">()</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># augment periodic boundary if it wasnot done in .pckl file</span>
        <span class="k">if</span>  <span class="p">((</span><span class="ow">not</span> <span class="n">mesh</span><span class="o">.</span><span class="n">do_augmpbnd</span><span class="p">)</span> <span class="ow">and</span> <span class="n">do_augmpbnd</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">do_augmpbnd</span> <span class="ow">and</span> <span class="n">do_pbndfind</span><span class="p">):</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">pbnd_augment</span><span class="p">()</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># compute other properties if they are not stored in .pckl file or need </span>
        <span class="c1"># to me redone anyway since focus or meshrotation has changed</span>
        <span class="k">if</span> <span class="n">do_pbndfind</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">do_lsmask</span><span class="p">:</span> 
                <span class="c1"># if lsmask does not exist yet, compute  and augment it</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">lsmask</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">mesh</span><span class="o">.</span><span class="n">compute_lsmask</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">do_augmpbnd</span><span class="p">:</span> <span class="n">mesh</span><span class="o">.</span><span class="n">augment_lsmask</span><span class="p">()</span>
                <span class="c1"># if lsmask exist than only augment pbnd     </span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">do_augmpbnd</span><span class="p">:</span> <span class="n">mesh</span><span class="o">.</span><span class="n">augment_lsmask</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mesh</span><span class="o">.</span><span class="n">do_earea</span> <span class="ow">and</span> <span class="n">do_earea</span><span class="p">:</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">compute_e_area</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mesh</span><span class="o">.</span><span class="n">do_eresol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">do_eresol</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">compute_e_resol</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="n">do_eresol</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mesh</span><span class="o">.</span><span class="n">do_narea</span> <span class="ow">and</span> <span class="n">do_narea</span> <span class="p">:</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">compute_n_area</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mesh</span><span class="o">.</span><span class="n">do_nresol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">do_nresol</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">compute_n_resol</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="n">do_nresol</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mesh</span><span class="o">.</span><span class="n">do_lsmask</span> <span class="ow">and</span> <span class="n">do_lsmask</span><span class="p">:</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">compute_lsmask</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">do_augmpbnd</span><span class="p">:</span>
                    <span class="n">mesh</span><span class="o">.</span><span class="n">augment_lsmask</span><span class="p">()</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="k">return</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    
    <span class="c1"># (do_pickle==True and .pckl file does not exists) or (do_pickle=False)</span>
    <span class="k">elif</span> <span class="p">((</span><span class="n">do_pickle</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">loadpicklepath</span><span class="p">))</span> <span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">do_pickle</span><span class="p">)</span> <span class="ow">or</span> \
         <span class="p">((</span><span class="n">do_joblib</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">loadjoblibpath</span><span class="p">))</span> <span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">do_joblib</span><span class="p">):</span>
             
        <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; load mesh from *.out files: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">meshpath</span><span class="p">))</span>
        <span class="c1">#_______________________________________________________________________</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_fesom2</span><span class="p">(</span>
                        <span class="n">meshpath</span>   <span class="o">=</span> <span class="n">meshpath</span>     <span class="p">,</span> 
                        <span class="n">abg</span>        <span class="o">=</span> <span class="n">abg</span>          <span class="p">,</span> 
                        <span class="n">focus</span>      <span class="o">=</span> <span class="n">focus</span>        <span class="p">,</span>
                        <span class="n">cyclic</span>     <span class="o">=</span> <span class="n">cyclic</span>       <span class="p">,</span>
                        <span class="n">do_rot</span>     <span class="o">=</span> <span class="n">do_rot</span>       <span class="p">,</span>
                        <span class="n">do_augmpbnd</span><span class="o">=</span> <span class="n">do_augmpbnd</span>  <span class="p">,</span>
                        <span class="n">do_cavity</span>  <span class="o">=</span> <span class="n">do_cavity</span>    <span class="p">,</span>
                        <span class="n">do_info</span>    <span class="o">=</span> <span class="n">do_info</span>      <span class="p">,</span>
                        <span class="n">do_earea</span>   <span class="o">=</span> <span class="n">do_earea</span>     <span class="p">,</span>
                        <span class="n">do_eresol</span>  <span class="o">=</span> <span class="n">do_eresol</span>    <span class="p">,</span>
                        <span class="n">do_narea</span>   <span class="o">=</span> <span class="n">do_narea</span>     <span class="p">,</span>
                        <span class="n">do_nresol</span>  <span class="o">=</span> <span class="n">do_nresol</span>    <span class="p">,</span>
                        <span class="n">do_lsmask</span>  <span class="o">=</span> <span class="n">do_lsmask</span>    <span class="p">,</span>
                        <span class="n">do_lsmshp</span>  <span class="o">=</span> <span class="n">do_lsmshp</span>    <span class="p">,</span>
                        <span class="n">do_loadraw</span> <span class="o">=</span> <span class="n">do_loadraw</span>   <span class="p">,</span>
                        <span class="n">do_f14cmip6</span> <span class="o">=</span> <span class="n">do_f14cmip6</span>   <span class="p">,</span>
                        <span class="p">)</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># save mypy mesh .pckl file</span>
        <span class="c1"># --&gt; try 1.st to store it in the mesh in the meshfolder, will depend of </span>
        <span class="c1">#     there is permission to write</span>
        <span class="k">if</span> <span class="n">do_pickle</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span> 
                <span class="n">savepicklepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meshpath</span><span class="p">,</span><span class="n">picklefname</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; save mesh to *.pckl in </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">savepicklepath</span><span class="p">))</span>
                <span class="n">fid</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savepicklepath</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickleprotocol</span><span class="p">)</span>
                <span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="c1"># if no permission rights for writing in meshpath folder try </span>
            <span class="c1"># cachefolder   </span>
            <span class="k">except</span> <span class="ne">PermissionError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span> 
                    <span class="n">savepicklepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cachepath</span><span class="p">,</span><span class="n">picklefname</span><span class="p">)</span>
                    <span class="n">mesh</span><span class="o">.</span><span class="n">cachepath</span> <span class="o">=</span> <span class="n">cachepath</span>
                    <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; save mesh to *.pckl in </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">savepicklepath</span><span class="p">))</span>
                    <span class="n">fid</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savepicklepath</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span>
                    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickleprotocol</span><span class="p">)</span>
                    <span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">PermissionError</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &gt; could not write *.pckl file in </span><span class="si">{}</span><span class="s2"> or </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">meshpath</span><span class="p">,</span><span class="n">cachepath</span><span class="p">))</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># save mypy mesh .jlib file</span>
        <span class="c1"># --&gt; try 1.st to store it in the mesh in the meshfolder, will depend of </span>
        <span class="c1">#     there is permission to write</span>
        <span class="k">if</span> <span class="n">do_joblib</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span> 
                <span class="n">savejoblibpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meshpath</span><span class="p">,</span> <span class="n">joblibfname</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; save mesh to *.jlib in </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">savejoblibpath</span><span class="p">))</span>
                <span class="n">fid</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savejoblibpath</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span>
                <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickleprotocol</span><span class="p">)</span>
                <span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="c1"># if no permission rights for writing in meshpath folder try </span>
            <span class="c1"># cachefolder   </span>
            <span class="k">except</span> <span class="ne">PermissionError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span> 
                    <span class="n">savejoblibpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cachepath</span><span class="p">,</span><span class="n">joblibfname</span><span class="p">)</span>
                    <span class="n">mesh</span><span class="o">.</span><span class="n">cachepath</span> <span class="o">=</span> <span class="n">cachepath</span>
                    <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; save mesh to *.pckl in </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">savejoblibpath</span><span class="p">))</span>
                    <span class="n">fid</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savejoblibpath</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span>
                    <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickleprotocol</span><span class="p">)</span>
                    <span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">PermissionError</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &gt; could not write *.pckl file in </span><span class="si">{}</span><span class="s2"> or </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">meshpath</span><span class="p">,</span><span class="n">cachepath</span><span class="p">))</span>
        <span class="c1">#_______________________________________________________________________</span>
        <span class="k">return</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span></div>




<span class="c1"># _____________________________________________________________________________</span>
<span class="c1">#|                                                                             |</span>
<span class="c1">#|                        *** FESOM2.0 MESH CLASS ***                          |</span>
<span class="c1">#|                                                                             |</span>
<span class="c1">#|_____________________________________________________________________________|</span>
<div class="viewcode-block" id="mesh_fesom2">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.mesh_fesom2">[docs]</a>
<span class="k">class</span> <span class="nc">mesh_fesom2</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --&gt; Class that creates object that contains all information about FESOM2</span>
<span class="sd">        mesh. As minimum requirement the mesh path to the files nod2d.out,</span>
<span class="sd">        elem2d.out and aux3d.out has to be given, </span>
<span class="sd">    </span>
<span class="sd">    __________________________________________________</span>
<span class="sd">    </span>
<span class="sd">    Parameters:    </span>
<span class="sd">        </span>
<span class="sd">        see help(load_fesom_mesh)</span>
<span class="sd">    </span>
<span class="sd">    __________________________________________________</span>
<span class="sd">    </span>
<span class="sd">    Variables:    </span>
<span class="sd">    </span>
<span class="sd">        path:           str, path that leads to FESOM2.0 mesh files (.out)</span>
<span class="sd">        </span>
<span class="sd">        id:             str, identifies mesh </span>
<span class="sd">        </span>
<span class="sd">        n2dn:           int, number of 2d nodes </span>
<span class="sd">        </span>
<span class="sd">        n2de:           int, number of 2d elements</span>
<span class="sd">        </span>
<span class="sd">        n_x:            array, lon position of surface nodes </span>
<span class="sd">        </span>
<span class="sd">        n_y:            array, lat position of surface nodes </span>
<span class="sd">        </span>
<span class="sd">        e_i:            array, elemental array with 2d vertice indices, shape=[n2de,3] </span>
<span class="sd">        </span>
<span class="sd">        ___vertical info____________________________________</span>
<span class="sd">        </span>
<span class="sd">        nlev:           int, number of vertical full cell level</span>
<span class="sd">        </span>
<span class="sd">        zlev:           array, with full depth levels</span>
<span class="sd">        </span>
<span class="sd">        zmid:           array, with mid depth levels</span>
<span class="sd">        </span>
<span class="sd">        n_z:            array, bottom depth based on zlev[n_iz], </span>
<span class="sd">        </span>
<span class="sd">        n_iz:           array, number of full depth levels at vertices</span>
<span class="sd">        </span>
<span class="sd">        e_iz:           array, number of full depth levels at elem</span>
<span class="sd">        </span>
<span class="sd">        ___cavity info (if do_cavity==True)_________________</span>
<span class="sd">        </span>
<span class="sd">        n_ic:           array, full depth level index of cavity-ocean interface at vertices</span>
<span class="sd">                        </span>
<span class="sd">        e_ic:           array, full depth level index of cavity-ocean interface at elem</span>
<span class="sd">                        </span>
<span class="sd">        n_c:            array, cavity-ocean interface depth at vertices zlev[n_ic]</span>
<span class="sd">        </span>
<span class="sd">        ___area and resoltion info___________________________</span>
<span class="sd">        </span>
<span class="sd">        n_area:         array, area at vertices</span>
<span class="sd">        </span>
<span class="sd">        n_resol:        array, resolutionat vertices</span>
<span class="sd">        </span>
<span class="sd">        e_area:         array, area at elements</span>
<span class="sd">        </span>
<span class="sd">        e_resol:        array, resolution at elements</span>
<span class="sd">        </span>
<span class="sd">        ___periodic boundary augmentation____________________</span>
<span class="sd">        </span>
<span class="sd">        n_xa:           array, with augmented vertice paramters</span>
<span class="sd">        </span>
<span class="sd">        n_ya:           ...</span>
<span class="sd">        </span>
<span class="sd">        n_za:           ...</span>
<span class="sd">        </span>
<span class="sd">        n_iza:          ...</span>
<span class="sd">        </span>
<span class="sd">        n_ca:           ... </span>
<span class="sd">        </span>
<span class="sd">        n_ica:          ...</span>
<span class="sd">        </span>
<span class="sd">        e_ia:           array, element array with augmented triangles --&gt; np.vstack((mesh.e_i[mesh.e_pbnd_0,:],mesh.e_ia))</span>
<span class="sd">        </span>
<span class="sd">        e_pbnd_1:       array, elem indices of pbnd elements</span>
<span class="sd">        </span>
<span class="sd">        e_pbnd_0:       array, elem indices of not pbnd elements</span>
<span class="sd">        </span>
<span class="sd">        e_pbnd_a:       array, elem indices of periodic augmented elements --&gt; data_plot = np.hstack((data_plot[mesh.e_pbnd_0],data_plot[mesh.e_pbnd_a]))</span>
<span class="sd">        </span>
<span class="sd">        n_pbnd_a:       array, vertice indices to augment pbnd --&gt; data_plot = np.hstack((data_plot,data_plot[mesh.n_pbnd_a]))</span>
<span class="sd">        </span>
<span class="sd">        n2dna:          int, number of vertices with periodic boundary augmentation</span>
<span class="sd">        </span>
<span class="sd">        n2dea:          int, number of elements with periodic boundary augmentation</span>
<span class="sd">                        </span>
<span class="sd">                        </span>
<span class="sd">        ___land sea mask (if do_lsmask == True)______________</span>
<span class="sd">        </span>
<span class="sd">        lsmask: list(array1[npts,2], array2[npts,2], ...), contains all land-sea mask polygons for FESOM2 mesh, with periodic boundary</span>

<span class="sd">        lsmask_a: list(array1[npts,2], array2[npts,2], ...)contains all land-sea mask polygons for FESOM2 mesh, with augmented </span>
<span class="sd">        periodic boundary</span>

<span class="sd">        lsmask_p: polygon, contains polygon collection that can be plotted as </span>
<span class="sd">        closed polygon patches with ax.add_collection(PatchCollection</span>
<span class="sd">        (mesh.lsmask_p,facecolor=[0.7,0.7,0.7], edgecolor=&#39;k&#39;, linewidth=0.5))</span>
<span class="sd">    </span>
<span class="sd">    __________________________________________________</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>

<span class="sd">        mesh:       object, returns fesom_mesh object</span>

<span class="sd">    __________________________________________________</span>
<span class="sd">    </span>
<span class="sd">    Info:</span>
<span class="sd">    </span>
<span class="sd">    create matplotlib triangulation with augmented periodic boundary</span>
<span class="sd">    </span>
<span class="sd">    ::</span>
<span class="sd">        </span>
<span class="sd">        tri = Triangulation(np.hstack((mesh.n_x,mesh.n_xa)), </span>
<span class="sd">                            np.hstack((mesh.n_y,mesh.n_ya)),</span>
<span class="sd">                            np.vstack((mesh.e_i[mesh.e_pbnd_0,:],mesh.e_ia)))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#___INIT FESOM2.0 MESH OBJECT_______________________________________________</span>
    <span class="c1">#                                                                           </span>
    <span class="c1">#___________________________________________________________________________</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meshpath</span><span class="p">,</span> <span class="n">abg</span><span class="o">=</span><span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="o">-</span><span class="mi">90</span><span class="p">],</span> <span class="n">focus</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">cyclic</span><span class="o">=</span><span class="mi">360</span><span class="p">,</span> <span class="n">focus_old</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">do_rot</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> 
                 <span class="n">do_augmpbnd</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">do_cavity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">do_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">do_earea</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">do_earea2</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                 <span class="n">do_eresol</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span><span class="s1">&#39;mean&#39;</span><span class="p">],</span> <span class="n">do_narea</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">do_nresol</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span><span class="s1">&#39;n_area&#39;</span><span class="p">],</span> 
                 <span class="n">do_lsmask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">do_lsmshp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">do_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">do_loadraw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">do_f14cmip6</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># define meshpath and mesh id </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span>               <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">meshpath</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cachepath</span>          <span class="o">=</span> <span class="s1">&#39;None&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span>                 <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_txt</span>           <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># define euler angles and mesh focus </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abg</span>                <span class="o">=</span> <span class="n">abg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">focus</span>              <span class="o">=</span> <span class="n">focus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">focus_old</span>          <span class="o">=</span> <span class="n">focus_old</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">cyclic</span>             <span class="o">=</span> <span class="n">cyclic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_rot</span>             <span class="o">=</span> <span class="n">do_rot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_augmpbnd</span>        <span class="o">=</span> <span class="n">do_augmpbnd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_cavity</span>          <span class="o">=</span> <span class="n">do_cavity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_earea</span>           <span class="o">=</span> <span class="n">do_earea</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_eresol</span>          <span class="o">=</span> <span class="n">do_eresol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_narea</span>           <span class="o">=</span> <span class="n">do_narea</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_nresol</span>          <span class="o">=</span> <span class="n">do_nresol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_lsmask</span>          <span class="o">=</span> <span class="n">do_lsmask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_lsmshp</span>          <span class="o">=</span> <span class="n">do_lsmshp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_loadraw</span>         <span class="o">=</span> <span class="n">do_loadraw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_f14cmip6</span>         <span class="o">=</span> <span class="n">do_f14cmip6</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># define basic mesh file path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname_nod2d</span>        <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;nod2d.out&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_f14cmip6</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fname_nod3d</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;nod3d.out&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname_elem2d</span>       <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;elem2d.out&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname_aux3d</span>        <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;aux3d.out&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname_nlvls</span>        <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;nlvls.out&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname_elvls</span>        <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;elvls.out&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname_elvls_raw</span>    <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;elvls_raw.out&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname_cnlvls</span>       <span class="o">=</span> <span class="p">[]</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">fname_celvls</span>       <span class="o">=</span> <span class="p">[]</span>  
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># define vertices array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span><span class="p">,</span>     <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n2dn</span>               <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_xo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_yo</span>    <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># define elem array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n2de</span>     <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># define depth and topographic info for vertices and elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nlev</span>               <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zlev</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmid</span>    <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iz</span>     <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_iz</span>               <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># define cavity vertice and element arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ic</span>     <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_ic</span>               <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># define vertice and elements area</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_area</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_resol</span><span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>           
        <span class="bp">self</span><span class="o">.</span><span class="n">e_area</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">e_resol</span><span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># define element indices for periodic and non periodic elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_pbnd_1</span>           <span class="o">=</span> <span class="p">[]</span> <span class="c1"># elem indices of pbnd elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_pbnd_0</span>           <span class="o">=</span> <span class="p">[]</span> <span class="c1"># elem indices of not pbnd elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_pbnd_a</span>           <span class="o">=</span> <span class="p">[]</span> <span class="c1"># elem indices to augment left/right pbnd</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># define vertice and element arrays for periodic boundary augmentation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_xa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ya</span>    <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">n_za</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ia</span>    <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iza</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ca</span>   <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_ica</span>              <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_ia</span>               <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1">#  elem array for augmented pbnd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_pbnd_a</span>           <span class="o">=</span> <span class="p">[]</span> <span class="c1"># vertice indices to augment pbnd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n2dna</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n2dea</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># define lsmask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lsmask</span>             <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lsmask_a</span>           <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lsmask_p</span>           <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1">#  ||   ||   ||   ||   ||   ||   ||   ||   ||   ||   ||   ||   ||   ||  </span>
        <span class="c1"># _||_ _||_ _||_ _||_ _||_ _||_ _||_ _||_ _||_ _||_ _||_ _||_ _||_ _||_ </span>
        <span class="c1"># \  / \  / \  / \  / \  / \  / \  / \  / \  / \  / \  / \  / \  / \  / </span>
        <span class="c1">#  \/   \/   \/   \/   \/   \/   \/   \/   \/   \/   \/   \/   \/   \/  </span>
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># read fesom mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_mesh</span><span class="p">()</span>
        
        <span class="c1"># read cavity depth info </span>
        <span class="k">if</span> <span class="n">do_cavity</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_cavity</span><span class="p">()</span>
        
        <span class="c1"># rotate mesh</span>
        <span class="k">if</span>   <span class="p">(</span><span class="n">do_rot</span> <span class="o">==</span> <span class="s1">&#39;r2g&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_xo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_yo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span> <span class="o">=</span> <span class="n">grid_r2g</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_xo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_yo</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">do_rot</span> <span class="o">==</span> <span class="s1">&#39;g2r&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_xo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_yo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span> <span class="o">=</span> <span class="n">grid_g2r</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_xo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_yo</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">do_rot</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">do_rot</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">):</span>    
            <span class="o">...</span>
        <span class="k">else</span><span class="p">:</span> 
           <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This rotatio option in do_rot is not supported.&quot;</span><span class="p">)</span>
        
        
        <span class="c1"># we assume that the center focus of the mesh is at 0deg (-180...180) </span>
        <span class="c1"># check if this right change focus </span>
        <span class="n">src_focus</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="o">.</span><span class="n">min</span><span class="p">()))</span><span class="o">*</span><span class="mf">0.5</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">src_focus</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_xo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_yo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span> <span class="o">=</span> <span class="n">grid_focus</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_xo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_yo</span><span class="p">)</span>
        
        <span class="c1"># now change focus to destined longitude</span>
        <span class="c1"># cartopy always assumes that the input grid goes from -180...180 it than can internally</span>
        <span class="c1"># rotate the grid to a different focus</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">focus</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">n_xo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_yo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span> <span class="o">=</span> <span class="n">grid_focus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">focus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_xo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_yo</span><span class="p">)</span>
        
        <span class="c1"># find periodic boundary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbnd_find</span><span class="p">()</span>
        
        <span class="c1"># augment periodic boundary</span>
        <span class="k">if</span> <span class="n">do_augmpbnd</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cyclic</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pbnd_augment</span><span class="p">()</span>
        
        <span class="c1"># compute/load element area</span>
        <span class="k">if</span> <span class="n">do_earea</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_e_area</span><span class="p">()</span>
        
        <span class="c1"># compute element resolution</span>
        <span class="k">if</span> <span class="n">do_eresol</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_e_resol</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="n">do_eresol</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># compute vertices area</span>
        <span class="k">if</span> <span class="n">do_narea</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_n_area</span><span class="p">()</span>
        
        <span class="c1"># compute vertices resolution interpolate elem to vertices</span>
        <span class="k">if</span> <span class="n">do_nresol</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_n_resol</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="n">do_nresol</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># compute lsmask</span>
        <span class="k">if</span> <span class="n">do_lsmask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_lsmask</span><span class="p">()</span>
            
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># save land-sea mask with periodic boundnaries to shapefile</span>
            <span class="k">if</span> <span class="n">do_lsmshp</span><span class="p">:</span>
                <span class="n">shpfname</span> <span class="o">=</span> <span class="s1">&#39;tripyview_fesom2&#39;</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="s1">&#39;pbnd&#39;</span>
                <span class="n">lsmask_2shapefile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lsmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lsmask</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">shpfname</span><span class="p">)</span>
            
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># augment periodic boundaries of land sea mask</span>
            <span class="k">if</span> <span class="n">do_augmpbnd</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">augment_lsmask</span><span class="p">()</span>
                
                <span class="c1">#_______________________________________________________________</span>
                <span class="c1"># save land-sea mask with augmented  pbnd to shapefile</span>
                <span class="k">if</span> <span class="n">do_lsmshp</span><span class="p">:</span>
                    <span class="n">lsmask_2shapefile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">lsmask</span><span class="o">=</span><span class="p">[])</span>
            
        <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>


    
    <span class="c1"># ___READ FESOM2 MESH FROM: nod2d.out, elem2d.out,...______________________</span>
    <span class="c1">#| read files: nod2d.out, elem2d.out, aux3d.out, nlvls.out, elvls.out      |                                                         </span>
    <span class="c1">#|_________________________________________________________________________|</span>
<div class="viewcode-block" id="mesh_fesom2.read_mesh">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.mesh_fesom2.read_mesh">[docs]</a>
    <span class="k">def</span> <span class="nf">read_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        --&gt; part of fesom mesh class, read mesh files nod2d.out, elem2d.out, </span>
<span class="sd">        aux3d.out, nlvls.out and elvls.out   </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#____load 2d node matrix________________________________________________</span>
        <span class="c1">#file_content = pa.read_csv(self.fname_nod2d, delim_whitespace=True, skiprows=1, \</span>
        <span class="n">file_content</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_nod2d</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">s+&#39;</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> \
                                      <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;node_number&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;flag&#39;</span><span class="p">]</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span>     <span class="o">=</span> <span class="n">file_content</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span>     <span class="o">=</span> <span class="n">file_content</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_i</span>     <span class="o">=</span> <span class="n">file_content</span><span class="o">.</span><span class="n">flag</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span>   
        <span class="bp">self</span><span class="o">.</span><span class="n">n2dn</span>    <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">)</span>
        
        <span class="c1">#____load 2d element matrix_____________________________________________</span>
        <span class="c1">#file_content = pa.read_csv(self.fname_elem2d, delim_whitespace=True, skiprows=1, \</span>
        <span class="n">file_content</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_elem2d</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">s+&#39;</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> \
                                    <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;1st_node_in_elem&#39;</span><span class="p">,</span><span class="s1">&#39;2nd_node_in_elem&#39;</span><span class="p">,</span><span class="s1">&#39;3rd_node_in_elem&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_i</span>     <span class="o">=</span> <span class="n">file_content</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n2de</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># print(&#39;    : #2de={:d}&#39;.format(self.n2de))</span>
        
        <span class="c1">#____load 3d nodes alligned under 2d nodes______________________________</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_f14cmip6</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_aux3d</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nlev</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">zlev</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlev</span><span class="p">)])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">zlev</span><span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zlev</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zmid</span>    <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zlev</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">zlev</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">/</span><span class="mf">2.</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t1</span><span class="o">=</span><span class="n">clock</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="c1"># number of vertical levels</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_aux3d</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlev</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
            
            <span class="c1"># 3d vertice index below surface vertices index</span>
            <span class="n">file_content</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_aux3d</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nlev</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n2dn</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n32</span>     <span class="o">=</span> <span class="n">file_content</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n32</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n32</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n2dn</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nlev</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            
            <span class="c1"># Lick out bufferlayer in fesom1.4 mesh</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n32</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n32</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nlev</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlev</span><span class="o">-</span><span class="mi">1</span>
            
            <span class="c1"># identify the vertical levels</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_nod3d</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span> <span class="n">n3dn</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
            <span class="c1">#file_content = pa.read_csv(self.fname_nod3d, delim_whitespace=True, usecols=[3])</span>
            <span class="n">file_content</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_nod3d</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">s+&#39;</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">aux_n3z</span>      <span class="o">=</span> <span class="n">file_content</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">zlev</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">aux_n3z</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1">#self.zlev    = np.hstack((self.zlev, self.zlev[-1]+(self.zlev[-1]-self.zlev[-2])))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zmid</span>    <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zlev</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">zlev</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">/</span><span class="mf">2.</span>
            
            <span class="c1"># compute bottom topography at vertice</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_z</span>     <span class="o">=</span> <span class="n">aux_n3z</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n32</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">del</span><span class="p">(</span><span class="n">aux_n3z</span><span class="p">)</span>
            
            <span class="c1"># compute bottom index at vertice</span>
            <span class="n">aux_n32</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n32</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">aux_n32</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n32</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_iz</span>    <span class="o">=</span> <span class="n">aux_n32</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>

        
        <span class="c1">#____load number of levels at each node_________________________________</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_nlvls</span><span class="p">)</span> <span class="p">):</span>
            <span class="c1">#file_content = pa.read_csv(self.fname_nlvls, delim_whitespace=True, skiprows=0, \</span>
            <span class="n">file_content</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_nlvls</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">s+&#39;</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> \
                                           <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;numb_of_lev&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_iz</span>    <span class="o">=</span> <span class="n">file_content</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_iz</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iz</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_z</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zlev</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iz</span><span class="p">])</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_f14cmip6</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; --&gt; you are in fesom1.4 mode, no nlvls information!&#39;</span><span class="p">)</span>    
        <span class="k">else</span>                <span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; --&gt; could not find file </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_nlvls</span><span class="si">}</span><span class="s1"> !&#39;</span><span class="p">)</span>
            <span class="c1">#self.n_iz    = np.zeros((self.n2dn,)) </span>
            <span class="c1">#self.n_z     = np.zeros((self.n2dn,)) </span>
        
        <span class="c1">#____load number of levels at each elem_________________________________</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_elvls</span><span class="p">)</span> <span class="p">):</span>
            <span class="c1">#file_content = pa.read_csv(self.fname_elvls, delim_whitespace=True, skiprows=0, \</span>
            <span class="n">file_content</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_elvls</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">s+&#39;</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> \
                                           <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;numb_of_lev&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">e_iz</span>    <span class="o">=</span> <span class="n">file_content</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">e_iz</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_iz</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_f14cmip6</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; --&gt; you are in fesom1.4 mode, no elvls information!&#39;</span><span class="p">)</span>        
        <span class="k">else</span>                <span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; --&gt; could not find file </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_elvls</span><span class="si">}</span><span class="s1"> !&#39;</span><span class="p">)</span>
            <span class="c1">#self.e_iz    = np.zeros((self.n2de,)) </span>
        
        <span class="c1">#____load number of raw levels at each elem_____________________________</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">do_loadraw</span> <span class="ow">and</span>  <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_f14cmip6</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_elvls_raw</span><span class="p">)</span> <span class="p">):</span>
                <span class="c1">#file_content = pa.read_csv(self.fname_elvls_raw, delim_whitespace=True, skiprows=0, \</span>
                <span class="n">file_content</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_elvls_raw</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">s+&#39;</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> \
                                            <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;numb_of_lev&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">e_iz_raw</span>    <span class="o">=</span> <span class="n">file_content</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">e_iz_raw</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_iz_raw</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; --&gt; could not find file </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_elvls_raw</span><span class="si">}</span><span class="s1"> !&#39;</span><span class="p">)</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># vertical level information of fesom1.4 mesh</span>
        <span class="c1">#if self.do_f14cmip6:</span>

        <span class="c1">#_______________________________________________________________________</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>    </div>

    
    
    
    <span class="c1"># ___READ FESOM2 MESH CAVITY INFO__________________________________________</span>
    <span class="c1">#| read files: cavity_nlvls.out, cavity_elvls.out                          |                                     </span>
    <span class="c1">#|_________________________________________________________________________|</span>
<div class="viewcode-block" id="mesh_fesom2.read_cavity">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.mesh_fesom2.read_cavity">[docs]</a>
    <span class="k">def</span> <span class="nf">read_cavity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        --&gt; part of fesom mesh class, read cavity mesh files, cavity_nlvls.out</span>
<span class="sd">        cavity_elvls.out and cavity_elvls_raw.out (if do_loadraw=True)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#____load number of cavity levels at each node__________________________</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname_cnlvls</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;cavity_nlvls.out&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_cnlvls</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">file_content</span>      <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_cnlvls</span><span class="p">,</span> <span class="n">delim_whitespace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;numb_of_lev&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_ic</span><span class="o">=</span> <span class="n">file_content</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_ic</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ic</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; --&gt; could not find file </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_cnlvls</span><span class="si">}</span><span class="s1"> !&#39;</span><span class="p">)</span>
        
        <span class="c1">#____load number of cavity levels at each elem__________________________</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname_celvls</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;cavity_elvls.out&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_cnlvls</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">file_content</span>      <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_celvls</span><span class="p">,</span> <span class="n">delim_whitespace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;numb_of_lev&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">e_ic</span><span class="o">=</span> <span class="n">file_content</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">e_ic</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_ic</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; --&gt; could not find file </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_celvls</span><span class="si">}</span><span class="s1"> !&#39;</span><span class="p">)</span>
        
        <span class="c1">#____load number of raw cavity levels at each elem______________________</span>
        <span class="c1"># number of cavity levels before it becomes iteratively optimse to avoid </span>
        <span class="c1"># isolated cells </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_loadraw</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fname_celvls_raw</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;cavity_elvls_raw.out&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_celvls_raw</span><span class="p">)</span> <span class="p">):</span> 
                <span class="n">file_content</span>    <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_celvls_raw</span><span class="p">,</span> <span class="n">delim_whitespace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;numb_of_lev&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">e_ic_raw</span>   <span class="o">=</span> <span class="n">file_content</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">e_ic_raw</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_ic_raw</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; --&gt; could not find file </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fname_celvls_raw</span><span class="si">}</span><span class="s1"> !&#39;</span><span class="p">)</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    
    
    
    <span class="c1">#___INFO ABOUT ACTUAL MESH OBJECT__________________________________________</span>
    <span class="c1">#| use as: print(mesh.info())                                              |</span>
    <span class="c1">#|_________________________________________________________________________|</span>
<div class="viewcode-block" id="mesh_fesom2.info">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.mesh_fesom2.info">[docs]</a>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_txt</span> <span class="o">=</span><span class="s2">&quot;&quot;&quot;___FESOM2 MESH INFO________________________</span>
<span class="s2"> &gt; path            = </span><span class="si">{}</span>
<span class="s2"> &gt; id              = </span><span class="si">{}</span>
<span class="s2"> &gt; do rot          = </span><span class="si">{}</span>
<span class="s2"> &gt; [al,be,ga]      = </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span>
<span class="s2"> &gt; do augmpbnd     = </span><span class="si">{}</span>
<span class="s2"> &gt; do cavity       = </span><span class="si">{}</span>
<span class="s2"> &gt; do lsmask       = </span><span class="si">{}</span>
<span class="s2"> &gt; do earea,eresol = </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span>
<span class="s2"> &gt; do narea,nresol = </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span>
<span class="s2">___________________________________________</span>
<span class="s2"> &gt; #node           = </span><span class="si">{}</span>
<span class="s2"> &gt; #elem           = </span><span class="si">{}</span>
<span class="s2"> &gt; #lvls           = </span><span class="si">{}</span>
<span class="s2">___________________________________________&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">do_rot</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abg</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abg</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abg</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">do_augmpbnd</span><span class="p">),</span>
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">do_cavity</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">do_lsmask</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">do_earea</span><span class="p">),</span> 
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">do_eresol</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">do_narea</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">do_nresol</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n2dn</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n2de</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlev</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_txt</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
    
    
    <span class="c1"># ___FIND PERIODIC BOUDNARY ELEMENTS_______________________________________</span>
    <span class="c1">#| find elements of periodic boundary (e_pbnd_1) and elements that do not  |</span>
    <span class="c1">#| participate in periodic boundary (e_pbnd_0)                             |</span>
    <span class="c1">#|_________________________________________________________________________|</span>
<div class="viewcode-block" id="mesh_fesom2.pbnd_find">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.mesh_fesom2.pbnd_find">[docs]</a>
    <span class="k">def</span> <span class="nf">pbnd_find</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        --&gt; part of fesom mesh class, find elements that cross over the periodic</span>
<span class="sd">        boundary</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># find out 1st which element contribute to periodic boundary and 2nd</span>
        <span class="c1"># which nodes are involed in periodic boundary</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_pbnd_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">dx</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cyclic</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_pbnd_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">dx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cyclic</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    
    
    
    <span class="c1"># ___AUGMENT PERIODIC BOUDNARY ELEMENTS____________________________________</span>
    <span class="c1">#| add additional elements to augment the periodic boundary on the left and|</span>
    <span class="c1">#| right side for an even non_periodic boundary                            |</span>
    <span class="c1">#|_________________________________________________________________________|</span>
<div class="viewcode-block" id="mesh_fesom2.pbnd_augment">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.mesh_fesom2.pbnd_augment">[docs]</a>
    <span class="k">def</span> <span class="nf">pbnd_augment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        --&gt; part of fesom mesh class, adds additional elements to augment the </span>
<span class="sd">        periodic boundary on the left and right side for an even non_periodic </span>
<span class="sd">        boundary is created left and right [-180, 180] of the domain         </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_augmpbnd</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># find which nodes are involed in periodic boundary</span>
        <span class="n">n_pbnd_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">e_pbnd_1</span><span class="p">,:])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">n_pbnd_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">n_pbnd_i</span><span class="p">)</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># find out node indices that contribute to the left side of the periodic </span>
        <span class="c1"># boundary (pbndn_l_2d_i) and to the right side (pbndn_r_2d_i)</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">aux_i</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[</span><span class="n">n_pbnd_i</span><span class="p">]</span><span class="o">&gt;</span><span class="p">(</span><span class="n">xmin</span><span class="o">+</span><span class="p">(</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">n_pbnd_i_r</span> <span class="o">=</span> <span class="n">n_pbnd_i</span><span class="p">[</span><span class="n">aux_i</span><span class="p">]</span>
        <span class="n">aux_i</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[</span><span class="n">n_pbnd_i</span><span class="p">]</span><span class="o">&lt;</span><span class="p">(</span><span class="n">xmin</span><span class="o">+</span><span class="p">(</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">n_pbnd_i_l</span> <span class="o">=</span> <span class="n">n_pbnd_i</span><span class="p">[</span><span class="n">aux_i</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_pbnd_a</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">n_pbnd_i_r</span><span class="p">,</span><span class="n">n_pbnd_i_l</span><span class="p">))</span>
        <span class="n">nn_il</span><span class="p">,</span><span class="n">nn_ir</span><span class="o">=</span> <span class="n">n_pbnd_i_l</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">n_pbnd_i_r</span><span class="o">.</span><span class="n">size</span>
        <span class="k">del</span> <span class="n">aux_i</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># calculate augmentation positions for new left and right periodic boundaries</span>
        <span class="n">aux_pos</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n2dn</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint32&#39;</span><span class="p">)</span>
        <span class="n">aux_i</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n2dn</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n2dn</span><span class="o">+</span><span class="n">nn_ir</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">nn_ir</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint32&#39;</span><span class="p">)</span>
        <span class="n">aux_pos</span><span class="p">[</span><span class="n">n_pbnd_i_r</span><span class="p">]</span> <span class="o">=</span><span class="n">aux_i</span>
        <span class="n">aux_i</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n2dn</span><span class="o">+</span><span class="n">nn_ir</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n2dn</span><span class="o">+</span><span class="n">nn_ir</span><span class="o">+</span><span class="n">nn_il</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">nn_il</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint32&#39;</span><span class="p">)</span>
        <span class="n">aux_pos</span><span class="p">[</span><span class="n">n_pbnd_i_l</span><span class="p">]</span><span class="o">=</span> <span class="n">aux_i</span> 
        <span class="k">del</span> <span class="n">aux_i</span><span class="p">,</span> <span class="n">n_pbnd_i_l</span><span class="p">,</span> <span class="n">n_pbnd_i_r</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># Augment the vertices on the right and left side </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cyclic</span> <span class="o">==</span> <span class="mi">360</span><span class="p">:</span>
            <span class="c1">#xmin, xmax= np.floor(xmin),np.ceil(xmax)</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">cyclic</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">focus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cyclic</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">focus</span>
        <span class="k">else</span><span class="p">:</span>    
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cyclic</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n_xa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nn_ir</span><span class="p">)</span><span class="o">+</span><span class="n">xmin</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nn_il</span><span class="p">)</span><span class="o">+</span><span class="n">xmax</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_ya</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pbnd_a</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_za</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_z</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pbnd_a</span><span class="p">]</span>
        <span class="c1"># self.n_ia = self.n_i[self.n_pbnd_a]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iza</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iz</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pbnd_a</span><span class="p">]</span>
        
        <span class="c1"># if there is cavity information</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_c</span> <span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ca</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_c</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pbnd_a</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_ic</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ica</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pbnd_a</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n2dna</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n2dn</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_pbnd_a</span><span class="o">.</span><span class="n">size</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># (ii.a) 2d elements:</span>
        <span class="c1"># List all triangles that touch the cyclic boundary segments</span>
        <span class="c1">#_______________________________________________________________________</span>
        <span class="n">elem_pbnd_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">e_pbnd_1</span><span class="p">,:])</span>
        <span class="n">elem_pbnd_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">elem_pbnd_l</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">e_pbnd_1</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="c1"># node indices of periodic boundary triangle</span>
            <span class="n">tri</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">e_pbnd_1</span><span class="p">[</span><span class="n">ei</span><span class="p">],:])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            
            <span class="c1"># which triangle points belong to left periodic bnde or right periodic</span>
            <span class="c1"># boundary</span>
            <span class="n">idx_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[</span><span class="n">tri</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">&lt;</span><span class="n">xmin</span><span class="o">+</span><span class="p">(</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">idx_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[</span><span class="n">tri</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">&gt;</span><span class="n">xmin</span><span class="o">+</span><span class="p">(</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># change indices to left and right augmented boundary points</span>
            <span class="n">elem_pbnd_l</span><span class="p">[</span><span class="n">ei</span><span class="p">,</span><span class="n">idx_r</span><span class="p">]</span><span class="o">=</span><span class="n">aux_pos</span><span class="p">[</span><span class="n">tri</span><span class="p">[</span><span class="n">idx_r</span><span class="p">]]</span>
            <span class="n">elem_pbnd_r</span><span class="p">[</span><span class="n">ei</span><span class="p">,</span><span class="n">idx_l</span><span class="p">]</span><span class="o">=</span><span class="n">aux_pos</span><span class="p">[</span><span class="n">tri</span><span class="p">[</span><span class="n">idx_l</span><span class="p">]]</span>
        <span class="k">del</span> <span class="n">idx_l</span><span class="p">,</span> <span class="n">idx_r</span><span class="p">,</span> <span class="n">tri</span><span class="p">,</span> <span class="n">aux_pos</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># change existing periodic boundary triangles in elem_2d_i to augmented </span>
        <span class="c1"># left boundary triangles</span>
        <span class="c1">#self.e_i[self.e_pbnd_1,:] = elem_pbnd_l</span>
        <span class="c1"># add additional augmented right periodic boundary triangles</span>
        <span class="c1">#self.e_ia = elem_pbnd_r</span>
        
        <span class="c1"># add augmented left, right periodic boundary triangles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_ia</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">elem_pbnd_r</span><span class="p">,</span><span class="n">elem_pbnd_l</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_pbnd_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">e_pbnd_1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">e_pbnd_1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n2dea</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n2de</span> <span class="o">+</span> <span class="n">elem_pbnd_r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    

    <span class="c1">#___COMPUTE/LOAD AREA OF ELEMENTS__________________________________________</span>
    <span class="c1">#| either load area of elements from fesom.mesh.diag.nc if its found in    |</span>
    <span class="c1">#| meshpath or recompute it from scratch, [m^2]                            |</span>
    <span class="c1">#|_________________________________________________________________________|</span>
<div class="viewcode-block" id="mesh_fesom2.compute_e_area">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.mesh_fesom2.compute_e_area">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_e_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        --&gt; part of fesom mesh class, either load area of elements from </span>
<span class="sd">        fesom.mesh.diag.nc if its found in meshpath or recompute it from </span>
<span class="sd">        scratch, [m^2]             </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># just compute e_area if mesh.area is empty </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_area</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_earea</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;fesom.mesh.diag.nc&#39;</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; load e_area from fesom.mesh.diag.nc&#39;</span><span class="p">)</span>
                <span class="c1">#_______________________________________________________________</span>
                <span class="n">fid</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;fesom.mesh.diag.nc&#39;</span><span class="p">),</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">e_area</span> <span class="o">=</span> <span class="n">fid</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;elem_area&#39;</span><span class="p">][:]</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; comp e_area&#39;</span><span class="p">)</span>
                <span class="c1">#_______________________________________________________________</span>
                <span class="c1"># pi     = 3.14159265358979</span>
                <span class="n">rad</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span>  
                <span class="n">cycl</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cyclic</span><span class="o">*</span><span class="n">rad</span>
                <span class="n">Rearth</span> <span class="o">=</span> <span class="mf">6367500.0</span>
                
                <span class="n">e_y</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">3.0</span>
                <span class="n">e_y</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">e_y</span><span class="o">*</span><span class="n">rad</span><span class="p">)</span>
                        
                <span class="n">n_xy</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span><span class="p">])</span><span class="o">*</span><span class="n">rad</span>     
                <span class="n">a</span>      <span class="o">=</span> <span class="n">n_xy</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">n_xy</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">b</span>      <span class="o">=</span> <span class="n">n_xy</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="n">n_xy</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span>  
                <span class="k">del</span><span class="p">(</span><span class="n">n_xy</span><span class="p">)</span>
                
                <span class="c1"># trim cyclic</span>
                <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">&gt;</span> <span class="n">cycl</span><span class="o">/</span><span class="mf">2.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">&gt;</span> <span class="n">cycl</span><span class="o">/</span><span class="mf">2.0</span><span class="p">]</span><span class="o">-</span><span class="n">cycl</span>
                <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">&lt;-</span><span class="n">cycl</span><span class="o">/</span><span class="mf">2.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">&lt;-</span><span class="n">cycl</span><span class="o">/</span><span class="mf">2.0</span><span class="p">]</span><span class="o">+</span><span class="n">cycl</span>
                <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">&gt;</span> <span class="n">cycl</span><span class="o">/</span><span class="mf">2.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">&gt;</span> <span class="n">cycl</span><span class="o">/</span><span class="mf">2.0</span><span class="p">]</span><span class="o">-</span><span class="n">cycl</span>
                <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">&lt;-</span><span class="n">cycl</span><span class="o">/</span><span class="mf">2.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">&lt;-</span><span class="n">cycl</span><span class="o">/</span><span class="mf">2.0</span><span class="p">]</span><span class="o">+</span><span class="n">cycl</span>
                
                <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">e_y</span>
                <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">e_y</span>
                <span class="k">del</span><span class="p">(</span><span class="n">e_y</span><span class="p">)</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">e_area</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,:])</span><span class="o">*</span><span class="p">(</span><span class="n">Rearth</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
                <span class="k">del</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="c1">#_______________________________________________________________________</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    
    
    <span class="c1"># ___COMPUTE RESOLUTION OF ELEMENTS________________________________________</span>
    <span class="c1">#| compute area of elements in [m], options:                               |</span>
    <span class="c1">#| which :   str,                                                          |       </span>
    <span class="c1">#|           &quot;mean&quot;: resolution based on mean element edge legth           |</span>
    <span class="c1">#|           &quot;max&quot; : resolution based on maximum element edge length       |</span>
    <span class="c1">#|           &quot;min&quot; : resolution based on minimum element edge length       |</span>
    <span class="c1">#|_________________________________________________________________________|</span>
<div class="viewcode-block" id="mesh_fesom2.compute_e_resol">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.mesh_fesom2.compute_e_resol">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_e_resol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        --&gt; part of fesom mesh class, compute area of elements in [m], options:</span>

<span class="sd">            Parameter:</span>

<span class="sd">                which: str,</span>
<span class="sd">                        - &quot;mean&quot; ... resolution based on mean element edge legth</span>
<span class="sd">                        - &quot;max&quot;  ... resolution based on maximum element edge length</span>
<span class="sd">                        - &quot;min&quot;  ... resolution based on minimum element edge length</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_resol</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_eresol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_eresol</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">which</span>
            
            <span class="c1">#______________::::_________________________________________________</span>
            <span class="c1"># compute mean length of triangle sides</span>
            <span class="n">e_y</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">]</span>
            <span class="n">e_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">],</span> <span class="n">e_y</span><span class="p">])</span>
                
            <span class="c1">#__________::::_____________________________________________________</span>
            <span class="c1"># calc jacobi matrix for all triangles </span>
            <span class="c1"># | dx_12 dy_12 |</span>
            <span class="c1"># | dx_13 dy_13 |_i , i=1....n2dea</span>
            <span class="n">jacobian</span>     <span class="o">=</span> <span class="n">e_xy</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">e_xy</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">jacobian</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">jacobian</span><span class="p">,</span>
                                        <span class="n">e_xy</span><span class="p">[:,:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">e_xy</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="n">e_xy</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">e_xy</span><span class="p">[:,:,</span><span class="mi">2</span><span class="p">]</span> <span class="p">])</span>
                
            <span class="c1"># account for triangles with periodic bounaries</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">jacobian</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">&gt;</span><span class="mi">180</span><span class="p">);</span> 
                <span class="n">jacobian</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">jacobian</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">idx</span><span class="p">]</span><span class="o">-</span><span class="mi">360</span><span class="p">;</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">jacobian</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">&lt;-</span><span class="mi">180</span><span class="p">);</span> 
                <span class="n">jacobian</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">jacobian</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">idx</span><span class="p">]</span><span class="o">+</span><span class="mi">360</span><span class="p">;</span>
                <span class="k">del</span> <span class="n">idx</span>
                
            <span class="c1"># calc from geocoord to cartesian coord</span>
            <span class="n">rad</span>        <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
            <span class="n">R_earth</span>    <span class="o">=</span> <span class="mi">12735</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="mi">1000</span><span class="p">;</span>
            <span class="n">jacobian</span>   <span class="o">=</span> <span class="n">jacobian</span><span class="o">*</span><span class="n">R_earth</span><span class="o">*</span><span class="n">rad</span>
            <span class="n">cos_theta</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">e_y</span><span class="o">*</span><span class="n">rad</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">e_y</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>    
                <span class="n">jacobian</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">jacobian</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">cos_theta</span><span class="p">;</span>
            <span class="k">del</span> <span class="n">cos_theta</span>
                
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># calc vector length dr = sqrt(dx^2+dy^2)</span>
            <span class="n">jacobian</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">jacobian</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
            <span class="n">jacobian</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jacobian</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">));</span>
            <span class="n">jacobian</span>     <span class="o">=</span> <span class="n">jacobian</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># mean resolutiuon per element</span>
            <span class="k">if</span>  <span class="n">which</span><span class="o">==</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; comp. e_resol from mean&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">e_resol</span> <span class="o">=</span> <span class="n">jacobian</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">which</span><span class="o">==</span><span class="s1">&#39;max&#39;</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; comp. e_resol from max&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">e_resol</span> <span class="o">=</span> <span class="n">jacobian</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">which</span><span class="o">==</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; comp. e_resol from min&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">e_resol</span> <span class="o">=</span> <span class="n">jacobian</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>    
            <span class="c1">#___________________________________________________________________    </span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The option which=</span><span class="si">{}</span><span class="s2"> in compute_e_resol is not supported.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">which</span><span class="p">)))</span>
            
        <span class="c1">#_______________________________________________________________________</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    

    <span class="c1"># ___COMPUTE/LOAD CLUSTERAREA OF VERTICES__________________________________</span>
    <span class="c1">#| either load clusterarea of vertices from fesom.mesh.diag.nc if its found|  </span>
    <span class="c1">#| in meshpath or recompute it from scratch by using e_area, [m^2]         |</span>
    <span class="c1">#|_________________________________________________________________________|</span>
<div class="viewcode-block" id="mesh_fesom2.compute_n_area">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.mesh_fesom2.compute_n_area">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_n_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        --&gt; part of fesom mesh class, either load clusterarea of vertices from </span>
<span class="sd">        fesom.mesh.diag.nc if its found in meshpath or recompute it from scratch </span>
<span class="sd">        by using e_area, [m^2]     </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># just compute e_area if mesh.area is empty </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_area</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_narea</span><span class="o">=</span><span class="kc">True</span>
            
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># load FESOM2 mesh</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_f14cmip6</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;fesom.mesh.diag.nc&#39;</span><span class="p">)):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; load n_area from fesom.mesh.diag.nc&#39;</span><span class="p">)</span>
                    <span class="c1">#_______________________________________________________________</span>
                    <span class="n">fid</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;fesom.mesh.diag.nc&#39;</span><span class="p">),</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">n_area</span> <span class="o">=</span> <span class="n">fid</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;nod_area&#39;</span><span class="p">][:,:]</span>
                <span class="k">else</span><span class="p">:</span> 
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; comp n_area&#39;</span><span class="p">)</span>
                    <span class="c1">#_______________________________________________________________</span>
                    <span class="c1"># be sure that elemente area already exists</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">compute_e_area</span><span class="p">()</span>
                    
                    <span class="c1">#_______________________________________________________________</span>
                    <span class="n">e_area_x3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">e_area</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_area</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_area</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="n">e_iz_n</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">e_iz</span>  <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_iz</span>  <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_iz</span>  <span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    
                    <span class="c1">#_______________________________________________________________</span>
                    <span class="c1"># single loop over self.e_i.flat is ~4 times faster than douple loop </span>
                    <span class="c1"># over for i in range(3): ,for j in range(self.n2de):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">n_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nlev</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n2dn</span><span class="p">))</span>
                    <span class="n">count_e</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="o">.</span><span class="n">flat</span><span class="p">:</span>
                        <span class="n">e_iz</span> <span class="o">=</span> <span class="n">e_iz_n</span><span class="p">[</span><span class="n">count_e</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">n_area</span><span class="p">[:</span><span class="n">e_iz</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_area</span><span class="p">[:</span><span class="n">e_iz</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">e_area_x3</span><span class="p">[</span><span class="n">count_e</span><span class="p">]</span>
                        <span class="n">count_e</span> <span class="o">=</span> <span class="n">count_e</span><span class="o">+</span><span class="mi">1</span> <span class="c1"># count triangle index for aux_area[count] --&gt; aux_area =[n2de*3,]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">n_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_area</span><span class="o">/</span><span class="mf">3.0</span>
                    <span class="k">del</span> <span class="n">e_area_x3</span><span class="p">,</span> <span class="n">e_iz_n</span><span class="p">,</span> <span class="n">count_e</span>
            
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># load FESOM1.4 mesh</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;griddes.nc&#39;</span><span class="p">)):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; load n_area from griddes.nc&#39;</span><span class="p">)</span>
                    <span class="c1">#_______________________________________________________________</span>
                    <span class="n">fid</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span><span class="s1">&#39;griddes.nc&#39;</span><span class="p">),</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">n_area</span> <span class="o">=</span> <span class="n">fid</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;cell_area&#39;</span><span class="p">][:]</span>
                <span class="k">else</span><span class="p">:</span> 
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; comp n_area&#39;</span><span class="p">)</span>
                    <span class="c1"># be sure that elemente area already exists</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">compute_e_area</span><span class="p">()</span>
                    
                    <span class="c1">#_______________________________________________________________</span>
                    <span class="n">e_area_x3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">e_area</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_area</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_area</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    
                    <span class="c1">#_______________________________________________________________</span>
                    <span class="c1"># single loop over self.e_i.flat is ~4 times faster than douple loop </span>
                    <span class="c1"># over for i in range(3): ,for j in range(self.n2de):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">n_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n2dn</span><span class="p">))</span>
                    <span class="n">count_e</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="o">.</span><span class="n">flat</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">n_area</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_area</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">e_area_x3</span><span class="p">[</span><span class="n">count_e</span><span class="p">]</span>
                        <span class="n">count_e</span> <span class="o">=</span> <span class="n">count_e</span><span class="o">+</span><span class="mi">1</span> <span class="c1"># count triangle index for aux_area[count] --&gt; aux_area =[n2de*3,]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">n_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_area</span><span class="o">/</span><span class="mf">3.0</span>
                    <span class="k">del</span> <span class="n">e_area_x3</span><span class="p">,</span> <span class="n">count_e</span>
        <span class="c1">#_______________________________________________________________________</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>




    <span class="c1"># ___COMPUTE RESOLUTION OF AT VERTICES_____________________________________</span>
    <span class="c1">#| compute resolution at vertices in m                                     |</span>
    <span class="c1">#| which :   str,                                                          |       </span>
    <span class="c1">#|           &quot;n_area&quot; : compute resolution based on vertice cluster area   |</span>
    <span class="c1">#|           &quot;e_resol&quot;: compute vertice resolution by interpolating elem   |</span>
    <span class="c1">#|                      resolution to vertices, default                    |</span>
    <span class="c1">#|_________________________________________________________________________|</span>
<div class="viewcode-block" id="mesh_fesom2.compute_n_resol">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.mesh_fesom2.compute_n_resol">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_n_resol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;n_area&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        --&gt; part of fesom mesh class, compute resolution at vertices in m, options:</span>

<span class="sd">            Parameter:</span>

<span class="sd">                which: str,</span>
<span class="sd">                        - &quot;n_area&quot; ... compute resolution based on vertice cluster area</span>
<span class="sd">                        - &quot;e_resol&quot;  ... compute vertice resolution by interpolating elem resolution to vertices, default      </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># just compute e_area if mesh.area is empty </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_resol</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_nresol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_nresol</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">which</span>
            
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># compute vertices resolution based on vertice clusterarea</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">which</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;n_area&#39;</span><span class="p">,</span><span class="s1">&#39;narea&#39;</span><span class="p">]):</span> 
                
                <span class="c1">#_______________________________________________________________</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_n_area</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; comp n_resol from n_area&#39;</span><span class="p">)</span>
                <span class="c1">#_______________________________________________________________</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_resol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_area</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="mf">2.0</span>
            
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># compute vertices resolution based on interpolation from resolution</span>
            <span class="c1"># of elements    </span>
            <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">which</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;e_resol&#39;</span><span class="p">,</span><span class="s1">&#39;eresol&#39;</span><span class="p">]):</span>
            
                <span class="c1">#_______________________________________________________________</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_e_area</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_e_resol</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_n_area</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; comp n_resol from e_resol&#39;</span><span class="p">)</span>
                <span class="n">aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">e_area</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">e_area</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">e_area</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">aux</span> <span class="o">=</span> <span class="n">aux</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">e_resol</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">e_resol</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">e_resol</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    
                <span class="c1">#_______________________________________________________________</span>
                <span class="c1"># single loop over self.e_i.flat is ~4 times faster than douple loop </span>
                <span class="c1"># over for i in range(3): ,for j in range(self.n2de):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_resol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n2dn</span><span class="p">,))</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="o">.</span><span class="n">flat</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">n_resol</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_resol</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">aux</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
                    <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span> <span class="c1"># count triangle index for aux_area[count] --&gt; aux_area =[n2de*3,]</span>
                <span class="k">del</span> <span class="n">aux</span><span class="p">,</span> <span class="n">count</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;divide by zero encountered in divide&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_resol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_resol</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_area</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">/</span><span class="mf">3.0</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">resetwarnings</span><span class="p">()</span>
            <span class="c1">#___________________________________________________________________    </span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The option which=</span><span class="si">{}</span><span class="s2"> in compute_n_resol is not supported. either &#39;n_area&#39; or &#39;e_resol&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">which</span><span class="p">)))</span>
            
        <span class="c1">#_______________________________________________________________________</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    
    
    <span class="c1"># ___COMPUTE LAND-SEA MASK CONOURLINE______________________________________</span>
    <span class="c1">#| compute land-sea mask contourline with periodic boundary based on edges |</span>
    <span class="c1">#| that contribute only to one triangle and the checking which edges are   |</span>
    <span class="c1">#| consequtive connected                                                   |                   </span>
    <span class="c1">#|_________________________________________________________________________|</span>
<div class="viewcode-block" id="mesh_fesom2.compute_lsmask">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.mesh_fesom2.compute_lsmask">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_lsmask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        --&gt; part of fesom mesh class, compute land-sea mask contourline with </span>
<span class="sd">        periodic boundary based on boundary edges that contribute only to one triangle </span>
<span class="sd">        and then checking which edges can be consequtive connected                                                   |</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; compute lsmask&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_lsmask</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># build land boundary edge matrix</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">edge</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> \
                                  <span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span> \
                                  <span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">[:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">edge</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
        
        <span class="c1"># python  sortrows algorythm --&gt; matlab equivalent</span>
        <span class="c1"># twice as fast as list sorting</span>
        <span class="c1">#sortidx = np.lexsort((edge[:,0],edge[:,1]))</span>
        <span class="c1">#edge    = edge[sortidx,:].squeeze()</span>
        <span class="c1">#edge    = np.array(edge)</span>
        
        <span class="c1">## python  sortrows algorythm --&gt; matlab equivalent</span>
        <span class="n">edge</span>    <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">edge</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">edge</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        
        <span class="n">idx</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span>
        <span class="n">idx</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">idx</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">]))),</span>\
                                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">]),</span><span class="n">idx</span><span class="p">)))</span>
        
        <span class="c1"># all edges that belong to boundary</span>
        <span class="n">bnde</span>    <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="n">idx</span><span class="o">==</span><span class="kc">False</span><span class="p">,:]</span>
        <span class="n">nbnde</span>   <span class="o">=</span> <span class="n">bnde</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">del</span> <span class="n">edge</span><span class="p">,</span> <span class="n">idx</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="n">run_cont</span>        <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">nbnde</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">run_cont</span><span class="p">[</span><span class="mi">0</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span>  <span class="o">=</span> <span class="n">bnde</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>  <span class="c1"># initialise the first landmask edge</span>
        <span class="n">run_bnde</span>        <span class="o">=</span> <span class="n">bnde</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="c1"># remaining edges that still need to be distributed</span>
        <span class="n">count_init</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">init_ind</span>        <span class="o">=</span> <span class="n">run_cont</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">ind_lc_s</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="n">polygon_xy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nbnde</span><span class="p">):</span>
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># search for next edge that contains that contains the last node index from </span>
            <span class="c1"># run_cont</span>
            <span class="n">kk_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">run_bnde</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">run_cont</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">count_init</span><span class="p">])</span> <span class="p">))</span>
            <span class="c1">#kk_rc = np.argwhere( run_bnde==np.int32(run_cont[0,count_init]) ) --&gt; slower than np.column_stack(np.where....</span>
            <span class="n">kk_r</span>  <span class="o">=</span> <span class="n">kk_rc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">kk_c</span>  <span class="o">=</span> <span class="n">kk_rc</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">count_init</span>  <span class="o">=</span> <span class="n">count_init</span><span class="o">+</span><span class="mi">1</span>
            
            <span class="c1">#___________________________________________________________________</span>
            <span class="k">if</span> <span class="n">kk_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
                <span class="n">run_cont</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">count_init</span><span class="p">]</span> <span class="o">=</span> <span class="n">run_bnde</span><span class="p">[</span><span class="n">kk_r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">run_cont</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">count_init</span><span class="p">]</span> <span class="o">=</span> <span class="n">run_bnde</span><span class="p">[</span><span class="n">kk_r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span>
                
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># if a land sea mask polygon is closed</span>
            <span class="k">if</span>  <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">run_bnde</span><span class="p">[</span><span class="n">kk_r</span><span class="p">[</span><span class="mi">0</span><span class="p">],:]</span> <span class="o">==</span> <span class="n">init_ind</span><span class="p">):</span>
                <span class="c1">#_______________________________________________________________</span>
                <span class="c1"># add points to polygon_list</span>
                <span class="n">aux_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">run_cont</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">count_init</span><span class="o">+</span><span class="mi">1</span><span class="p">])],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">n_y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">run_cont</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">count_init</span><span class="o">+</span><span class="mi">1</span><span class="p">])]))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="n">polygon_xy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_xy</span><span class="p">)</span>
                <span class="k">del</span>  <span class="n">aux_xy</span>
                
                <span class="c1">#_______________________________________________________________</span>
                <span class="c1"># delete point from list</span>
                <span class="n">run_bnde</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">run_bnde</span><span class="p">,</span><span class="n">kk_r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>
                
                <span class="c1">#_______________________________________________________________</span>
                <span class="c1"># if no points left break the while loop</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">run_bnde</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                
                <span class="c1">#_______________________________________________________________</span>
                <span class="c1"># initialise new lsmask contour</span>
                <span class="n">run_cont</span>        <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">nbnde</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">run_cont</span><span class="p">[</span><span class="mi">0</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span>  <span class="o">=</span> <span class="n">run_bnde</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
                <span class="n">run_bnde</span>        <span class="o">=</span> <span class="n">run_bnde</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>
                <span class="n">count_init</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">init_ind</span>        <span class="o">=</span> <span class="n">run_cont</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">run_bnde</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">run_bnde</span><span class="p">,</span><span class="n">kk_r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>
            
        <span class="c1">#_______________________________________________________________________</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lsmask</span> <span class="o">=</span> <span class="n">polygon_xy</span>
        <span class="c1">#t2 = clock.time()</span>
        <span class="c1">#print(t2-t1)</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    
    
    
    <span class="c1"># ___AUGMENT PERIODIC BOUNDARIES IN LAND-SEA MASK CONOURLINE_______________</span>
    <span class="c1">#| spilit contourlines that span over the periodic boundary into two       |</span>
    <span class="c1">#| separated countourlines for the left and right side of the periodic     |</span>
    <span class="c1">#| boundaries                                                              |</span>
    <span class="c1">#|_________________________________________________________________________|</span>
<div class="viewcode-block" id="mesh_fesom2.augment_lsmask">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.mesh_fesom2.augment_lsmask">[docs]</a>
    <span class="k">def</span> <span class="nf">augment_lsmask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        --&gt; part of fesom mesh class, split contourlines that span over the </span>
<span class="sd">        periodic boundary into two separated countourlines for the left and </span>
<span class="sd">        right side of the periodic boundaries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; augment lsmask&#39;</span><span class="p">)</span>
        <span class="c1">#self.lsmask_a = self.lsmask.copy()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lsmask_a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># build land boundary edge matrix</span>
        <span class="n">nlsmask</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lsmask</span><span class="p">)</span>
        
        <span class="c1"># min/max of longitude box </span>
        <span class="c1"># xmin,xmax = -180+self.focus, 180+self.focus</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nlsmask</span><span class="p">):</span>
            <span class="c1">#___________________________________________________________________</span>
            <span class="n">polygon_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lsmask</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1">#import matplotlib.pyplot as plt </span>
            <span class="c1">#plt.figure()</span>
            <span class="c1">#plt.plot(polygon_xy[:,0], polygon_xy[:,1])</span>
            <span class="c1">#plt.show()</span>
            
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># idx compute how many periodic boudnaries are in the polygon </span>
            <span class="n">idx</span>        <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lsmask</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">lsmask</span><span class="p">[</span><span class="n">ii</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">cyclic</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            
            <span class="c1">#___________________________________________________________________</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="c1"># unify starting point of polygon, the total polygon should start</span>
                <span class="c1"># at the left periodic boudnary at the most northward periodic point</span>
                <span class="n">aux_i</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">aux_x</span>      <span class="o">=</span> <span class="n">polygon_xy</span><span class="p">[</span><span class="n">aux_i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1">#aux_il     = np.sort(aux_i[np.argwhere(aux_x &lt; self.focus).ravel()])</span>
                <span class="n">aux_il</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">aux_i</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">aux_x</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">xmin</span><span class="o">+</span><span class="n">xmax</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span>
                <span class="n">isort_y</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">polygon_xy</span><span class="p">[</span><span class="n">aux_il</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">aux_il</span>     <span class="o">=</span> <span class="n">aux_il</span><span class="p">[</span><span class="n">isort_y</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">isort_y</span><span class="p">,</span> <span class="n">aux_x</span><span class="p">,</span> <span class="n">aux_i</span>
                
                <span class="c1"># shift polygon indices so that new starting point is at index 0</span>
                <span class="n">polygon_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span> <span class="p">(</span><span class="n">polygon_xy</span><span class="p">[</span><span class="n">aux_il</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,:]),(</span><span class="n">polygon_xy</span><span class="p">[:</span><span class="n">aux_il</span><span class="p">[</span><span class="mi">0</span><span class="p">],:])</span> <span class="p">))</span>
                <span class="k">del</span> <span class="n">aux_il</span>
                
                <span class="c1"># ensure that total polygon is closed</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">polygon_xy</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],:])</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span> <span class="n">polygon_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span> <span class="p">(</span><span class="n">polygon_xy</span><span class="p">,</span><span class="n">polygon_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span> <span class="p">))</span>
            
            <span class="k">else</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">lsmask_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon_xy</span><span class="p">)</span>   
                <span class="k">continue</span>
            
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># recompute indices of periodic boundaries </span>
            <span class="c1"># check if lsmask contour contains 0 (no periodic boundary), 1 (polar</span>
            <span class="c1"># contour) or &gt;2 (non polar contour) pbnd edges. </span>
            <span class="c1"># idx = np.argwhere(np.abs(self.lsmask[ii][1:,0]-self.lsmask[ii][:-1,0])&gt;self.cyclic/2).ravel()</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">polygon_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">polygon_xy</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">cyclic</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># none polar lsmask contour with pbnd boundary that needs to be cutted</span>
            <span class="c1"># in two or more polygons</span>
            <span class="k">if</span>   <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">aux_i</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">aux_x</span>      <span class="o">=</span> <span class="n">polygon_xy</span><span class="p">[</span><span class="n">aux_i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                
                <span class="c1"># compure index location of left and right pbnd points</span>
                <span class="c1">#aux_il     = np.sort(aux_i[np.argwhere(aux_x &lt; self.focus).ravel()])</span>
                <span class="c1">#aux_ir     = np.sort(aux_i[np.argwhere(aux_x &gt; self.focus).ravel()])</span>
                <span class="n">aux_il</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">aux_i</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">aux_x</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">xmin</span><span class="o">+</span><span class="n">xmax</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span>
                <span class="n">aux_ir</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">aux_i</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">aux_x</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">xmin</span><span class="o">+</span><span class="n">xmax</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span>
                <span class="k">del</span> <span class="n">aux_x</span><span class="p">,</span> <span class="n">aux_i</span>
                
                <span class="c1">#_______________________________________________________________</span>
                <span class="c1"># do polygon on left periodic boundary</span>
                <span class="n">polygon_xyl</span> <span class="o">=</span> <span class="n">polygon_xy</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">aux_il</span><span class="p">),</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">polygon_xyl</span><span class="p">[[</span><span class="n">aux_il</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span><span class="n">aux_il</span><span class="p">[</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">xmin</span>
                    <span class="n">polygon_xyl</span><span class="p">[</span><span class="n">aux_ir</span><span class="p">[</span><span class="n">jj</span><span class="p">]:</span><span class="n">aux_ir</span><span class="p">[</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    
                <span class="c1"># eliminate nab points from right boundary    </span>
                <span class="n">polygon_xyl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">polygon_xyl</span><span class="p">,</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">polygon_xyl</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>    
                
                <span class="c1"># close polygon</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">polygon_xyl</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],:])</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span> 
                    <span class="n">polygon_xyl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span> <span class="p">(</span><span class="n">polygon_xyl</span><span class="p">,</span><span class="n">polygon_xyl</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span> <span class="p">))</span>
                
                <span class="c1">## polygon must have at last 3 points</span>
                <span class="c1">#if polygon_xyl.shape[0]==2: </span>
                    <span class="c1">#polygon_xyl = np.vstack(( polygon_xyl, polygon_xyl[0,:] ))</span>
                    
                <span class="bp">self</span><span class="o">.</span><span class="n">lsmask_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon_xyl</span><span class="p">)</span>
                
                <span class="c1">#_______________________________________________________________</span>
                <span class="c1"># do polygon on right periodic boundary</span>
                <span class="n">polygon_xyr</span> <span class="o">=</span> <span class="n">polygon_xy</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">polygon_xyr</span><span class="p">[</span><span class="n">aux_ir</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="n">xmax</span>   
                <span class="n">polygon_xyr</span><span class="p">[:</span><span class="n">aux_il</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>   
                <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">aux_ir</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">polygon_xyr</span><span class="p">[[</span><span class="n">aux_ir</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span><span class="n">aux_ir</span><span class="p">[</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xmax</span>
                    <span class="n">polygon_xyr</span><span class="p">[</span><span class="n">aux_il</span><span class="p">[</span><span class="n">jj</span><span class="p">]:</span><span class="n">aux_il</span><span class="p">[</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">polygon_xyr</span><span class="p">[</span><span class="n">aux_ir</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="n">xmax</span>
                <span class="n">polygon_xyr</span><span class="p">[</span><span class="n">aux_il</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  
                
                <span class="c1"># eliminate nan points from left boudnary</span>
                <span class="n">polygon_xyr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">polygon_xyr</span><span class="p">,</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">polygon_xyr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>    
                
                <span class="c1"># close polygon</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">polygon_xyr</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],:])</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span> 
                    <span class="n">polygon_xyr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span> <span class="p">(</span><span class="n">polygon_xyr</span><span class="p">,</span><span class="n">polygon_xyr</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span> <span class="p">))</span>
                
                <span class="c1">## polygon must have at last 3 points</span>
                <span class="c1">#if polygon_xyr.shape[0]==2: </span>
                    <span class="c1">#polygon_xyr = np.vstack(( polygon_xyr, polygon_xyr[0,:] ))</span>
                    
                <span class="bp">self</span><span class="o">.</span><span class="n">lsmask_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon_xyr</span><span class="p">)</span>
                
                <span class="k">del</span> <span class="n">polygon_xy</span><span class="p">,</span> <span class="n">aux_il</span><span class="p">,</span> <span class="n">aux_ir</span>
                
            <span class="c1">#polar lsmask contour with pbnd boundary</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1">#_______________________________________________________________</span>
                <span class="c1"># create single  polar polygon</span>
                <span class="n">aux_i</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="c1">#aux_x,aux_y= self.lsmask_a[ii][aux_i,0], self.lsmask_a[ii][aux_i,1]</span>
                <span class="n">aux_x</span><span class="p">,</span><span class="n">aux_y</span><span class="o">=</span> <span class="n">polygon_xy</span><span class="p">[</span><span class="n">aux_i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">polygon_xy</span><span class="p">[</span><span class="n">aux_i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                
                <span class="c1"># indeces for left and right pbnd points</span>
                <span class="c1">#aux_il     = np.sort(aux_i[np.argwhere(aux_x &lt; self.focus).ravel()])[0]</span>
                <span class="c1">#aux_ir     = np.sort(aux_i[np.argwhere(aux_x &gt; self.focus).ravel()])[0]</span>
                <span class="n">aux_il</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">aux_i</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">aux_x</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">xmin</span><span class="o">+</span><span class="n">xmax</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">aux_ir</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">aux_i</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">aux_x</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">xmin</span><span class="o">+</span><span class="n">xmax</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1">#polygon_xy = self.lsmask_a[ii]</span>
                
                <span class="c1"># set corner points for polar polygon</span>
                <span class="n">pbndl</span>   <span class="p">,</span><span class="n">pbndr</span>    <span class="o">=</span> <span class="n">polygon_xy</span><span class="p">[</span><span class="n">aux_ir</span><span class="p">,:],</span> <span class="n">polygon_xy</span><span class="p">[</span><span class="n">aux_il</span><span class="p">,:]</span>
                <span class="n">pbndl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pbndr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">aux_y</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span> 
                    <span class="n">pcrnl</span><span class="p">,</span> <span class="n">pcrnr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xmax</span><span class="p">,</span><span class="o">-</span><span class="mi">90</span><span class="p">],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pcrnl</span><span class="p">,</span> <span class="n">pcrnr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="mi">90</span><span class="p">],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xmax</span><span class="p">,</span><span class="mi">90</span><span class="p">],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                
                <span class="c1"># augment and close polygon wit corner points</span>
                <span class="k">if</span> <span class="n">aux_ir</span><span class="o">&lt;</span><span class="n">aux_il</span><span class="p">:</span>
                    <span class="n">polygon_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span>  <span class="n">polygon_xy</span><span class="p">[:</span><span class="n">aux_ir</span><span class="p">,:],</span> 
                                           <span class="n">pbndr</span><span class="p">,</span> <span class="n">pcrnr</span><span class="p">,</span> <span class="n">pcrnl</span> <span class="p">,</span><span class="n">pbndl</span><span class="p">,</span> 
                                           <span class="n">polygon_xy</span><span class="p">[</span><span class="n">aux_il</span><span class="o">+</span><span class="mi">1</span><span class="p">:,:]</span>  <span class="p">))</span>
                    
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">polygon_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span>  <span class="n">polygon_xy</span><span class="p">[:</span><span class="n">aux_il</span><span class="p">,:],</span> 
                                           <span class="n">pbndl</span><span class="p">,</span> <span class="n">pcrnl</span><span class="p">,</span> <span class="n">pcrnr</span> <span class="p">,</span><span class="n">pbndr</span><span class="p">,</span> 
                                           <span class="n">polygon_xy</span><span class="p">[</span><span class="n">aux_ir</span><span class="o">+</span><span class="mi">1</span><span class="p">:,:]</span>  <span class="p">))</span>
                
                <span class="c1">## polygon must have at least 3 points</span>
                <span class="c1">#if polygon_xy.shape[0]==2: </span>
                    <span class="c1">#polygon_xy = np.vstack(( polygon_xy,polygon_xy[0,:] ))</span>
                    
                <span class="bp">self</span><span class="o">.</span><span class="n">lsmask_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon_xy</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">polygon_xy</span><span class="p">,</span> <span class="n">pbndr</span><span class="p">,</span> <span class="n">pcrnr</span><span class="p">,</span> <span class="n">pcrnl</span> <span class="p">,</span><span class="n">pbndl</span><span class="p">,</span> 
                <span class="k">del</span> <span class="n">aux_il</span><span class="p">,</span> <span class="n">aux_ir</span><span class="p">,</span> <span class="n">aux_i</span><span class="p">,</span> <span class="n">aux_x</span><span class="p">,</span> <span class="n">aux_y</span>
                
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># create lsmask patch to plot </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lsmask_p</span> <span class="o">=</span> <span class="n">lsmask_patch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lsmask_a</span><span class="p">)</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
</div>




<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#____COMPUTE POLYGON PATCH FROM LAND-SEA MASK CONTOUR___________________________</span>
<div class="viewcode-block" id="lsmask_patch">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.lsmask_patch">[docs]</a>
<span class="k">def</span> <span class="nf">lsmask_patch</span><span class="p">(</span><span class="n">lsmask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;    </span>
<span class="sd">    --&gt; computes polygon collection that can be plotted as closed polygon patches</span>
<span class="sd">    with ax.add_collection(PatchCollection(mesh.lsmask_p,</span>
<span class="sd">    facecolor=[0.7,0.7,0.7], edgecolor=&#39;k&#39;,linewidth=0.5))</span>

<span class="sd">    Parameters:</span>
<span class="sd">    </span>
<span class="sd">        lsmask: list()</span>
<span class="sd">            list([array1[npts,2], array2[npts,2]], ...) \n</span>
<span class="sd">            array1=np.array([ [x1,y1]; [x2,y2]; ...  ])</span>
<span class="sd">    </span>

<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    </span>
<span class="sd">        :lsmask_p: shapely Multipolygon object</span>
<span class="sd">        </span>
<span class="sd">    Info:</span>
<span class="sd">    </span>
<span class="sd">        - how to plot in matplotlib:</span>
<span class="sd">          from descartes import PolygonPatch</span>
<span class="sd">          ax.add_patch(PolygonPatch(mesh.lsmask_p,facecolor=[0.7,0.7,0.7],</span>
<span class="sd">        </span>
<span class="sd">        - how to plot in cartopy:</span>
<span class="sd">          import cartopy.crs as ccrs</span>
<span class="sd">          ax.add_geometries(mesh.lsmask_p, crs=ccrs.PlateCarree(), facecolor=[0.6,0.6,0.6], edgecolor=&#39;k&#39;,</span>
<span class="sd">          linewidth=0.5)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span>
    <span class="c1">#___________________________________________________________________________</span>
    <span class="n">polygonlist</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">xycoord</span> <span class="ow">in</span> <span class="n">lsmask</span><span class="p">:</span> <span class="n">polygonlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">xycoord</span><span class="p">))</span>
    <span class="n">lsmask_p</span> <span class="o">=</span> <span class="n">MultiPolygon</span><span class="p">(</span><span class="n">polygonlist</span><span class="p">)</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="k">return</span><span class="p">(</span><span class="n">lsmask_p</span><span class="p">)</span></div>




<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#___SAVE POLYGON LAND-SEA MASK CONTOUR TO SHAPEFILE_____________________________</span>
<div class="viewcode-block" id="lsmask_2shapefile">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.lsmask_2shapefile">[docs]</a>
<span class="k">def</span> <span class="nf">lsmask_2shapefile</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">lsmask</span><span class="o">=</span><span class="p">[],</span> <span class="n">path</span><span class="o">=</span><span class="p">[],</span> <span class="n">fname</span><span class="o">=</span><span class="p">[],</span> <span class="n">do_info</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --&gt; save FESOM2 grid land-sea mask polygons to shapefile</span>

<span class="sd">    Parameters:</span>
<span class="sd">    </span>
<span class="sd">        :mesh:      fesom2 mesh object, contains periodic augmented land-sea mask</span>
<span class="sd">                    polygonss in mesh.lsmask_a</span>
<span class="sd">                    </span>
<span class="sd">        :lsmask:    list, if empty mesh.lsmask_a is stored in shapefile, if not</span>
<span class="sd">                    empty lsmask=lsmaskin than lsmaskin will be stored in</span>
<span class="sd">                    </span>
<span class="sd">        :path:      strm, if empty mesh.path (or cache path depending on writing</span>
<span class="sd">                    permission) is used as location to store the shapefile, if</span>
<span class="sd">                    path=pathin than this string serves as location to store</span>
<span class="sd">                    .shp file</span>
<span class="sd">                    </span>
<span class="sd">        :fname:     str, if empty fixed filename is used mypymesh_fesom2_ID_focus=X.shp, </span>
<span class="sd">                    if not empty than fname=fnamein is used as filename for shape file</span>
<span class="sd">                    </span>
<span class="sd">        :do_info:   bool, print info where .shp file is saved, default = True</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    </span>
<span class="sd">        :return: nothing</span>
<span class="sd">        </span>
<span class="sd">    Info:</span>
<span class="sd">    </span>
<span class="sd">    --&gt; to load and plot shapefile patches</span>
<span class="sd">    </span>
<span class="sd">    ::</span>
<span class="sd">    </span>
<span class="sd">        import shapefile as shp</span>
<span class="sd">        from matplotlib.patches import Polygon</span>
<span class="sd">        from matplotlib.collections import PatchCollection</span>
<span class="sd">        </span>
<span class="sd">        shpfname = &#39;tripyview_fesom2&#39;+&#39;_&#39;+mesh.id+&#39;_&#39;+</span>
<span class="sd">                &#39;{}={}&#39;.format(&#39;focus&#39;,mesh.focus)+&#39;.shp&#39;</span>
<span class="sd">        shppath  = os.path.join(mesh.cachepath,shpfname)</span>
<span class="sd">        </span>
<span class="sd">        sf = shp.Reader(shppath)</span>
<span class="sd">        patches = []</span>
<span class="sd">        for shape in sf.shapes(): patches.append(Polygon(shape.points))</span>
<span class="sd">        </span>
<span class="sd">        plt.figure()</span>
<span class="sd">        ax = plt.gca()</span>
<span class="sd">        ax.add_collection(PatchCollection(patches,</span>
<span class="sd">                        facecolor=[0.7,0.7,0.7],</span>
<span class="sd">                        edgecolor=&#39;k&#39;, linewidths=1.))</span>
<span class="sd">        ax.set_xlim([-180,180]) </span>
<span class="sd">        ax.set_ylim([-90,90])</span>
<span class="sd">        plt.show()</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
    <span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># Create an empty geopandas GeoDataFrame</span>
    <span class="n">newdata</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">())</span>

    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># Add every polygon to GeoDataFrame</span>
    
    <span class="c1"># do not use polygon that is stored in mesh object use polygon that is given </span>
    <span class="c1"># by lsmask=lsmask</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">lsmask</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">lsmask_a</span><span class="p">)):</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">lsmask_a</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="k">continue</span>
            
            <span class="c1"># Create a Shapely polygon from the coordinate-tuple list</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
            
            <span class="c1"># Insert the polygon into &#39;geometry&#39; -column at index 0</span>
            <span class="n">newdata</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">poly</span>
            <span class="n">newdata</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;polygon&#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">ii</span><span class="p">))</span>
            
    <span class="c1"># use polygon storred in mesh object</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">lsmask</span><span class="p">)):</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">lsmask</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="k">continue</span>
            
            <span class="c1"># Create a Shapely polygon from the coordinate-tuple list</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
            
            <span class="c1"># Insert the polygon into &#39;geometry&#39; -column at index 0</span>
            <span class="n">newdata</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">poly</span>
            <span class="n">newdata</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;polygon&#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">ii</span><span class="p">))</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># write shapefile either in meshpath when there is writing permission </span>
    <span class="c1"># otherwise write in cachepath</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">W_OK</span><span class="p">):</span> 
            <span class="n">shppath</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">path</span>
        <span class="k">else</span><span class="p">:</span>
<span class="c1">#             cachepath = path = os.environ.get(&#39;MYPY_MESHPATH&#39;, os.path.join(os.path.expanduser(&quot;~&quot;), &quot;mesh_mypycache&quot;))</span>
            <span class="n">cachepath</span> <span class="o">=</span> <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;MESHPATH_TRIPYVIEW&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">),</span> <span class="s2">&quot;meshcache_tripyview&quot;</span><span class="p">))</span>
            <span class="n">cachepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cachepath</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">cachepath</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; create cache directory: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cachepath</span><span class="p">))</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">cachepath</span><span class="p">)</span>
            <span class="n">shppath</span> <span class="o">=</span> <span class="n">cachepath</span>  
    <span class="c1"># if an extra path is given us this to store the shapefile         </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shppath</span> <span class="o">=</span> <span class="n">path</span>
        
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># write lsmask to shapefile </span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fname</span><span class="p">:</span>
        <span class="n">shpfname</span> <span class="o">=</span> <span class="s1">&#39;tripyview_fesom2&#39;</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">mesh</span><span class="o">.</span><span class="n">id</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;focus&#39;</span><span class="p">,</span><span class="n">mesh</span><span class="o">.</span><span class="n">focus</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.shp&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shpfname</span> <span class="o">=</span> <span class="n">fname</span><span class="o">+</span><span class="s1">&#39;.shp&#39;</span>
    <span class="n">shppath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">shppath</span><span class="p">,</span><span class="n">shpfname</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &gt; save *.shp to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">shppath</span><span class="p">))</span>
    <span class="n">newdata</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">shppath</span><span class="p">)</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="k">return</span></div>




<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># ___COMPUTE EULER ROTATION MATRIX_____________________________________________</span>
<div class="viewcode-block" id="grid_rotmat">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.grid_rotmat">[docs]</a>
<span class="k">def</span> <span class="nf">grid_rotmat</span><span class="p">(</span><span class="n">abg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --&gt; compute euler rotation matrix based on alpha, beta and gamma angle</span>

<span class="sd">    Parameters: </span>
<span class="sd">    </span>
<span class="sd">        :abg:   list, with euler angles [alpha, beta, gamma]</span>

<span class="sd">    Returns: </span>

<span class="sd">        :rmat:  array, [3 x 3] rotation matrix to transform from geo to rot</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#___________________________________________________________________________</span>
    <span class="n">rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="n">al</span>  <span class="o">=</span> <span class="n">abg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">rad</span> 
    <span class="n">be</span>  <span class="o">=</span> <span class="n">abg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">rad</span>
    <span class="n">ga</span>  <span class="o">=</span> <span class="n">abg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">rad</span>
        
    <span class="c1">#___________________________________________________________________________</span>
    <span class="n">rmat</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ga</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">al</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ga</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">be</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">al</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ga</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">al</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ga</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">be</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">al</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ga</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">be</span><span class="p">)</span> <span class="p">)</span>
        
    <span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ga</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">al</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ga</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">be</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">al</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ga</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">al</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ga</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">be</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">al</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ga</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">be</span><span class="p">)</span> <span class="p">)</span>
        
    <span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">be</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">al</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">be</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">al</span><span class="p">)</span> <span class="p">)</span>        
    <span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">be</span><span class="p">)</span> <span class="p">)</span>
        
    <span class="c1">#___________________________________________________________________________</span>
    <span class="k">return</span><span class="p">(</span><span class="n">rmat</span><span class="p">)</span></div>




<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># ___COMPUTE3D CARTESIAN COORDINAT_____________________________________________</span>
<div class="viewcode-block" id="grid_cart3d">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.grid_cart3d">[docs]</a>
<span class="k">def</span> <span class="nf">grid_cart3d</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span><span class="n">lat</span><span class="p">,</span><span class="n">R</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">is_deg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --&gt; compute 3d cartesian coordinates from spherical geo coordinates (lon, lat, R=1.0)                                                           |</span>
<span class="sd">        </span>
<span class="sd">    Parameters: </span>
<span class="sd">    </span>
<span class="sd">        :lon:       array, longitude coordinates in radians</span>
<span class="sd">        </span>
<span class="sd">        :lat:       array, latitude coordinates in radians</span>
<span class="sd">        </span>
<span class="sd">        :R:         float, (default=1.0), Radius of sphere</span>
<span class="sd">        </span>
<span class="sd">        :is_deg:    bool, (default=False) is lon,lat in degree (True) otherwise </span>
<span class="sd">                    otherwise (False) assumed its in radians</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>

<span class="sd">        :x:         array, x y z cartesian coordinates </span>
<span class="sd">        </span>
<span class="sd">        :y:         ...</span>
<span class="sd">        </span>
<span class="sd">        :z:         ...</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_deg</span><span class="p">:</span> 
        <span class="n">rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">lat</span> <span class="o">*</span> <span class="n">rad</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">lon</span> <span class="o">*</span> <span class="n">rad</span>
    
    <span class="n">x</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
    <span class="c1">#___________________________________________________________________________</span>
    <span class="k">return</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span></div>




<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># ___ROTATE GRID FROM: ROT--&gt;GEO_______________________________________________</span>
<div class="viewcode-block" id="grid_r2g">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.grid_r2g">[docs]</a>
<span class="k">def</span> <span class="nf">grid_r2g</span><span class="p">(</span><span class="n">abg</span><span class="p">,</span> <span class="n">rlon</span><span class="p">,</span> <span class="n">rlat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --&gt; compute grid rotation from sperical rotated frame back towards normal geo</span>
<span class="sd">    frame using the euler angles alpha, beta, gamma</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    </span>
<span class="sd">        :abg:    list, with euler angles [alpha, beta, gamma]    </span>

<span class="sd">        :rlon:   array, longitude coordinates of sperical rotated frame in degree</span>

<span class="sd">        :rlat:   array,  latitude coordinates of sperical rotated frame in degree</span>

<span class="sd">    Returns: </span>

<span class="sd">        :lon:    array, longitude coordinates in normal geo frame in degree</span>

<span class="sd">        :lat:    array, latitude coordinates in normal geo frame in degree</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># build rotation matrix</span>
    <span class="n">rmat</span> <span class="o">=</span> <span class="n">grid_rotmat</span><span class="p">(</span><span class="n">abg</span><span class="p">)</span>
    <span class="n">rmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">rmat</span><span class="p">)</span>

    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># compute 3d cartesian coordinates</span>
    <span class="n">rad</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="n">rlat</span>     <span class="o">=</span> <span class="n">rlat</span> <span class="o">*</span> <span class="n">rad</span>
    <span class="n">rlon</span>     <span class="o">=</span> <span class="n">rlon</span> <span class="o">*</span> <span class="n">rad</span>
    <span class="n">xr</span><span class="p">,</span><span class="n">yr</span><span class="p">,</span><span class="n">zr</span> <span class="o">=</span> <span class="n">grid_cart3d</span><span class="p">(</span><span class="n">rlon</span><span class="p">,</span><span class="n">rlat</span><span class="p">)</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># rotate to geographical cartesian coordinates:</span>
    <span class="n">xg</span><span class="o">=</span><span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">yr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">zr</span><span class="p">;</span>
    <span class="n">yg</span><span class="o">=</span><span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">yr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">zr</span><span class="p">;</span>
    <span class="n">zg</span><span class="o">=</span><span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">yr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">zr</span><span class="p">;</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># compute to geographical coordinates:</span>
    <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">yg</span><span class="p">,</span><span class="n">xg</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">zg</span><span class="p">)</span>        
    <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">lon</span><span class="o">/</span><span class="n">rad</span><span class="p">,</span> <span class="n">lat</span><span class="o">/</span><span class="n">rad</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="k">return</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span><span class="n">lat</span><span class="p">)</span></div>



<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># ___ROTATE GRID FROM: GEO--&gt;ROT_______________________________________________</span>
<div class="viewcode-block" id="grid_g2r">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.grid_g2r">[docs]</a>
<span class="k">def</span> <span class="nf">grid_g2r</span><span class="p">(</span><span class="n">abg</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --&gt; compute grid rotation from normal geo frame towards sperical rotated</span>
<span class="sd">    frame using the euler angles alpha, beta, gamma</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    </span>
<span class="sd">        :abg:   list, with euler angles [alpha, beta, gamma]</span>
<span class="sd">        </span>
<span class="sd">        :lon:   array, longitude coordinates of normal geo frame in degree </span>
<span class="sd">        </span>
<span class="sd">        :lat:   array, latitude coordinates of normal geo frame in degree</span>
<span class="sd">        </span>
<span class="sd">    Returns:    </span>
<span class="sd">    </span>
<span class="sd">        :rlon:   array, longitude coordinates in sperical rotated frame in degree</span>
<span class="sd">        </span>
<span class="sd">        :rlat:   array, latitude coordinates in sperical rotated frame in degree</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># build rotation matrix</span>
    <span class="n">rmat</span> <span class="o">=</span> <span class="n">grid_rotmat</span><span class="p">(</span><span class="n">abg</span><span class="p">)</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># compute 3d cartesian coordinates</span>
    <span class="n">rad</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="n">lat</span>      <span class="o">=</span> <span class="n">lat</span> <span class="o">*</span> <span class="n">rad</span>
    <span class="n">lon</span>      <span class="o">=</span> <span class="n">lon</span> <span class="o">*</span> <span class="n">rad</span>
    <span class="n">xg</span><span class="p">,</span><span class="n">yg</span><span class="p">,</span><span class="n">zg</span> <span class="o">=</span> <span class="n">grid_cart3d</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span><span class="n">lat</span><span class="p">)</span>

    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># rotate to geographical cartesian coordinates:</span>
    <span class="n">xr</span><span class="o">=</span><span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xg</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">yg</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">zg</span><span class="p">;</span>
    <span class="n">yr</span><span class="o">=</span><span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xg</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">yg</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">zg</span><span class="p">;</span>
    <span class="n">zr</span><span class="o">=</span><span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xg</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">yg</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">zg</span><span class="p">;</span>

    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># compute to geographical coordinates:</span>
    <span class="n">rlon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">yr</span><span class="p">,</span><span class="n">xr</span><span class="p">)</span>     
    <span class="n">rlat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">zr</span><span class="p">)</span>        
    <span class="n">rlon</span> <span class="o">=</span> <span class="n">rlon</span><span class="o">/</span><span class="n">rad</span>
    <span class="n">rlat</span> <span class="o">=</span> <span class="n">rlat</span><span class="o">/</span><span class="n">rad</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="k">return</span><span class="p">(</span><span class="n">rlon</span><span class="p">,</span><span class="n">rlat</span><span class="p">)</span></div>




<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># ___ROTATE GRID FOCUS: 0--&gt;FOCUS______________________________________________</span>
<div class="viewcode-block" id="grid_focus">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.grid_focus">[docs]</a>
<span class="k">def</span> <span class="nf">grid_focus</span><span class="p">(</span><span class="n">focus</span><span class="p">,</span> <span class="n">rlon</span><span class="p">,</span> <span class="n">rlat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --&gt; compute grid rotation around z-axis to change the focus center of the lon,</span>
<span class="sd">    lat grid, by default focus=0--&gt;lon=[-180...180], if focus=180--&gt;lon[0..360] </span>
<span class="sd">    </span>
<span class="sd">    Parameters: </span>
<span class="sd">    </span>
<span class="sd">        :focus:  float, longitude of grid center</span>

<span class="sd">        :rlon:   array, longitude in focus=0--&gt;lon=[-180...180] in degree</span>

<span class="sd">        :rlat:   array, latitude in focus=0--&gt;lon=[-180...180] in degree</span>

<span class="sd">    Returns:    </span>

<span class="sd">        :lon:   array, longitude in lon=[-180+focus...180+focus] frame in degree</span>
<span class="sd">  </span>
<span class="sd">        :lat:   array, latitude in lon=[-180+focus...180+focus] frame in degree</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># build rotation matrix</span>
    <span class="n">abg</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">focus</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">rmat</span> <span class="o">=</span> <span class="n">grid_rotmat</span><span class="p">(</span><span class="n">abg</span><span class="p">)</span>
    <span class="n">rmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">rmat</span><span class="p">)</span>

    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># compute 3d cartesian coordinates</span>
    <span class="n">rad</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="n">rlat</span>     <span class="o">=</span> <span class="n">rlat</span> <span class="o">*</span> <span class="n">rad</span>
    <span class="n">rlon</span>     <span class="o">=</span> <span class="n">rlon</span> <span class="o">*</span> <span class="n">rad</span>
    <span class="n">xr</span><span class="p">,</span><span class="n">yr</span><span class="p">,</span><span class="n">zr</span> <span class="o">=</span> <span class="n">grid_cart3d</span><span class="p">(</span><span class="n">rlon</span><span class="p">,</span><span class="n">rlat</span><span class="p">)</span>

    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># rotate to geographical cartesian coordinates:</span>
    <span class="n">xg</span><span class="o">=</span><span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">yr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">zr</span><span class="p">;</span>
    <span class="n">yg</span><span class="o">=</span><span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">yr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">zr</span><span class="p">;</span>
    <span class="n">zg</span><span class="o">=</span><span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">yr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">zr</span><span class="p">;</span>

    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># compute to geographical coordinates:</span>
    <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">yg</span><span class="p">,</span><span class="n">xg</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">zg</span><span class="p">)</span>        
    <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">lon</span><span class="o">/</span><span class="n">rad</span><span class="p">,</span> <span class="n">lat</span><span class="o">/</span><span class="n">rad</span>
    <span class="n">lon</span>      <span class="o">=</span> <span class="n">lon</span> <span class="o">+</span> <span class="n">focus</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="k">return</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span><span class="n">lat</span><span class="p">)</span></div>

    
    

<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># ___ROTATE VECTOR FROM: ROT--&gt;GEO_____________________________________________</span>
<div class="viewcode-block" id="vec_r2g">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.vec_r2g">[docs]</a>
<span class="k">def</span> <span class="nf">vec_r2g</span><span class="p">(</span><span class="n">abg</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">urot</span><span class="p">,</span> <span class="n">vrot</span><span class="p">,</span> <span class="n">gridis</span><span class="o">=</span><span class="s1">&#39;geo&#39;</span><span class="p">,</span> <span class="n">do_info</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --&gt; In FESOM2 the vector variables are usually given in the rotated coordinate </span>
<span class="sd">    frame in which the model works and need to be rotated into normal geo    </span>
<span class="sd">    coordinates, however in the latest FESOM2 version there is also the option that</span>
<span class="sd">    they are rotated in the model via a flaf. So make sure what applies to you                                                           </span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        </span>
<span class="sd">        :abg:       list, with euler angles [alpha, beta, gamma]</span>
<span class="sd">        </span>
<span class="sd">        :lon:       array, longitude</span>
<span class="sd">        </span>
<span class="sd">        :lat:       array, latitude</span>
<span class="sd">        </span>
<span class="sd">        :urot:      array, zonal velocities in rotated frame</span>
<span class="sd">        </span>
<span class="sd">        :vrot:      array, meridional velocities in rotated frame</span>
<span class="sd">        </span>
<span class="sd">        :gridis:    str, in which coordinate frame are given lon, lat</span>
<span class="sd">                    &#39;geo&#39;,&#39;g&#39;,&#39;geographical&#39;: lon,lat is given in geo coordinates</span>
<span class="sd">                    &#39;rot&#39;,&#39;r&#39;,&#39;rotated&#39;     : lon,lat is given in rot coordinates</span>
<span class="sd">                    </span>
<span class="sd">    Returns:</span>
<span class="sd">    </span>
<span class="sd">        :ugeo:      array, zonal velocities in normal geo frame</span>
<span class="sd">        </span>
<span class="sd">        :vgeo:      array, meridional velocities in normal geo frame</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># create grid coorinates for geo and rotated frame</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">gridis</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;geo&#39;</span><span class="p">,</span><span class="s1">&#39;g&#39;</span><span class="p">,</span><span class="s1">&#39;geographical&#39;</span><span class="p">]):</span> 
        <span class="n">rlon</span><span class="p">,</span> <span class="n">rlat</span> <span class="o">=</span> <span class="n">grid_g2r</span><span class="p">(</span><span class="n">abg</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>        
    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">gridis</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rot&#39;</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="s1">&#39;rotated&#39;</span><span class="p">]):</span>     
        <span class="n">rlon</span><span class="p">,</span> <span class="n">rlat</span> <span class="o">=</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> 
        <span class="n">lon</span><span class="p">,</span>  <span class="n">lat</span>  <span class="o">=</span> <span class="n">grid_g2r</span><span class="p">(</span><span class="n">abg</span><span class="p">,</span> <span class="n">rlon</span><span class="p">,</span> <span class="n">rlat</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The option gridis=</span><span class="si">{}</span><span class="s2"> in vec_r2g is not supported.</span><span class="se">\n</span><span class="s2"> (only: &#39;geo&#39;,&#39;g&#39;,&#39;geographical&#39;, &#39;rot&#39;,&#39;r&#39;,&#39;rotated&#39;) &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">gridis</span><span class="p">)))</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># compute rotation matrix</span>
    <span class="n">rmat</span> <span class="o">=</span> <span class="n">grid_rotmat</span><span class="p">(</span><span class="n">abg</span><span class="p">)</span>
    <span class="n">rmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">rmat</span><span class="p">)</span>
    <span class="n">rad</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span> 

    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># degree --&gt; radian  </span>
    <span class="n">lon</span> <span class="p">,</span> <span class="n">lat</span>  <span class="o">=</span> <span class="n">lon</span><span class="o">*</span><span class="n">rad</span> <span class="p">,</span> <span class="n">lat</span><span class="o">*</span><span class="n">rad</span>
    <span class="n">rlon</span><span class="p">,</span> <span class="n">rlat</span> <span class="o">=</span> <span class="n">rlon</span><span class="o">*</span><span class="n">rad</span><span class="p">,</span> <span class="n">rlat</span><span class="o">*</span><span class="n">rad</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># rotation of one dimensional vector data</span>
    <span class="k">if</span> <span class="n">vrot</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">urot</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> 
        <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;     &gt; 1D rotation&#39;</span><span class="p">)</span>
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># compute vector in rotated cartesian coordinates</span>
        <span class="n">vxr</span> <span class="o">=</span> <span class="o">-</span><span class="n">vrot</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rlat</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rlon</span><span class="p">)</span> <span class="o">-</span> <span class="n">urot</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rlon</span><span class="p">)</span>
        <span class="n">vyr</span> <span class="o">=</span> <span class="o">-</span><span class="n">vrot</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rlat</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rlon</span><span class="p">)</span> <span class="o">+</span> <span class="n">urot</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rlon</span><span class="p">)</span>
        <span class="n">vzr</span> <span class="o">=</span>  <span class="n">vrot</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rlat</span><span class="p">)</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># compute vector in geo cartesian coordinates</span>
        <span class="n">vxg</span> <span class="o">=</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vxr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vyr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">vzr</span>
        <span class="n">vyg</span> <span class="o">=</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vxr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vyr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">vzr</span>
        <span class="n">vzg</span> <span class="o">=</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vxr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vyr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">vzr</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="c1"># compute vector in geo coordinates </span>
        <span class="n">vgeo</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vxg</span><span class="o">*-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">-</span> 
                       <span class="n">vyg</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">+</span> 
                       <span class="n">vzg</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">))</span>
        <span class="n">ugeo</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vxg</span><span class="o">*-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">+</span> <span class="n">vyg</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span>
        
    <span class="c1">#___________________________________________________________________________</span>
    <span class="c1"># rotation of two dimensional vector data    </span>
    <span class="k">elif</span> <span class="n">vrot</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">2</span> <span class="ow">or</span> <span class="n">urot</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> 
        <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;     &gt; 2D rotation&#39;</span><span class="p">)</span>
        <span class="n">nd1</span><span class="p">,</span><span class="n">nd2</span><span class="o">=</span><span class="n">urot</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">ugeo</span><span class="p">,</span> <span class="n">vgeo</span> <span class="o">=</span> <span class="n">urot</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">vrot</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;nlev:</span><span class="si">{:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nd2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">nd2i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nd2</span><span class="p">):</span>
            <span class="c1">#___________________________________________________________________</span>
            <span class="k">if</span> <span class="n">do_info</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:02d}</span><span class="s1">|&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nd2i</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">nd2i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="c1">#___________________________________________________________________</span>
            <span class="n">aux_urot</span><span class="p">,</span> <span class="n">aux_vrot</span> <span class="o">=</span> <span class="n">urot</span><span class="p">[:,</span><span class="n">nd2i</span><span class="p">],</span> <span class="n">vrot</span><span class="p">[:,</span><span class="n">nd2i</span><span class="p">]</span>
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># compute vector in rotated cartesian coordinates</span>
            <span class="n">vxr</span> <span class="o">=</span> <span class="o">-</span><span class="n">aux_vrot</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rlat</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rlon</span><span class="p">)</span> <span class="o">-</span> <span class="n">aux_urot</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rlon</span><span class="p">)</span>
            <span class="n">vyr</span> <span class="o">=</span> <span class="o">-</span><span class="n">aux_vrot</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rlat</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rlon</span><span class="p">)</span> <span class="o">+</span> <span class="n">aux_urot</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rlon</span><span class="p">)</span>
            <span class="n">vzr</span> <span class="o">=</span>  <span class="n">aux_vrot</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rlat</span><span class="p">)</span>
            
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># compute vector in geo cartesian coordinates</span>
            <span class="n">vxg</span> <span class="o">=</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vxr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vyr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">vzr</span>
            <span class="n">vyg</span> <span class="o">=</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vxr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vyr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">vzr</span>
            <span class="n">vzg</span> <span class="o">=</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vxr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vyr</span> <span class="o">+</span> <span class="n">rmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">vzr</span>
            
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># compute vector in geo coordinates </span>
            <span class="n">vgeo</span><span class="p">[:,</span><span class="n">nd2i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vxg</span><span class="o">*-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">-</span> 
                                   <span class="n">vyg</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">+</span> 
                                   <span class="n">vzg</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">))</span>
            <span class="n">ugeo</span><span class="p">[:,</span><span class="n">nd2i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vxg</span><span class="o">*-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">+</span> <span class="n">vyg</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span>
        
    <span class="c1">#___________________________________________________________________________    </span>
    <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;This number of dimensions is in moment not supported for vector rotation&#39;</span><span class="p">)</span>    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="k">return</span><span class="p">(</span><span class="n">ugeo</span><span class="p">,</span> <span class="n">vgeo</span><span class="p">)</span></div>




<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># ___CUTOUT REGION BASED ON BOX________________________________________________</span>
<div class="viewcode-block" id="grid_cutbox_e">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.grid_cutbox_e">[docs]</a>
<span class="k">def</span> <span class="nf">grid_cutbox_e</span><span class="p">(</span><span class="n">n_x</span><span class="p">,</span> <span class="n">n_y</span><span class="p">,</span> <span class="n">e_i</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;mid&#39;</span><span class="p">):</span><span class="c1"># , do_outTF=False):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --&gt; cutout region based on box and return mesh elements indices that are</span>
<span class="sd">    within the box                                                      </span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    </span>
<span class="sd">        :nx:        longitude vertice coordinates</span>

<span class="sd">        :ny:        latitude  vertice coordinates</span>

<span class="sd">        :e_i:       element array               </span>

<span class="sd">        :box:       list, [lonmin, lonmax, latmin, latmax]</span>

<span class="sd">        :which:     str, how limiting should be the selection</span>
<span class="sd">                    - &#39;soft&#39; : elem with at least 1 vertices in box are selected</span>
<span class="sd">                    - &#39;mid&#39;  : elem with at least 2 vertices in box are selected</span>
<span class="sd">                    - &#39;hard&#39; : elem with at all vertices in box are selected</span>

<span class="sd">    Returns:</span>
<span class="sd">    </span>
<span class="sd">        :e_inbox:   array, boolian array with 1 in box, 0 outside box</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="c1"># if the global selection box center is not at 0 (-180...180), also need to offset</span>
    <span class="c1"># cutting box</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">359</span> <span class="ow">and</span> <span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="mf">0.5</span><span class="o">!=</span><span class="mf">0.0</span><span class="p">:</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="mf">0.5</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="n">n_inbox</span> <span class="o">=</span> <span class="n">grid_cutbox_n</span><span class="p">(</span><span class="n">n_x</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="n">n_y</span><span class="p">,</span> <span class="n">box</span><span class="p">)</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="n">e_inbox</span> <span class="o">=</span> <span class="n">n_inbox</span><span class="p">[</span><span class="n">e_i</span><span class="p">]</span>
    
    <span class="c1"># considers triangles where at least one node is in box</span>
    <span class="k">if</span>   <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;soft&#39;</span><span class="p">:</span> <span class="n">e_inbox</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">e_inbox</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;mid&#39;</span> <span class="p">:</span> <span class="n">e_inbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e_inbox</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># considers triangles where all node must be in box (serated edge)</span>
    <span class="k">elif</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;hard&#39;</span><span class="p">:</span> <span class="n">e_inbox</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">e_inbox</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The option which=</span><span class="si">{}</span><span class="s2"> in grid_cutbox is not supported. </span><span class="se">\n</span><span class="s2">(only: &#39;hard&#39;, &#39;soft&#39;)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">which</span><span class="p">)))</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="k">return</span><span class="p">(</span><span class="n">e_inbox</span><span class="p">)</span></div>




<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># ___CUTOUT REGION BASED ON BOX________________________________________________</span>
<div class="viewcode-block" id="grid_cutbox_n">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.grid_cutbox_n">[docs]</a>
<span class="k">def</span> <span class="nf">grid_cutbox_n</span><span class="p">(</span><span class="n">n_x</span><span class="p">,</span> <span class="n">n_y</span><span class="p">,</span> <span class="n">box</span><span class="p">):</span><span class="c1"># , do_outTF=False):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --&gt; cutout region based on box and return mesh elements indices that are</span>
<span class="sd">    within the box</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    </span>
<span class="sd">        :nx:    longitude vertice coordinates</span>

<span class="sd">        :ny:    latitude  vertice coordinates</span>

<span class="sd">        :e_i:   element array                </span>

<span class="sd">        :box:   list, [lonmin, lonmax, latmin, latmax]</span>

<span class="sd">    Returns:    </span>

<span class="sd">        :n_inbox:   array, boolian array with 1 in box, 0 outside box</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#___________________________________________________________________________</span>
    <span class="n">n_inbox</span> <span class="o">=</span> <span class="p">((</span><span class="n">n_x</span> <span class="o">&gt;=</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n_x</span> <span class="o">&lt;=</span> <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> 
               <span class="p">(</span><span class="n">n_y</span> <span class="o">&gt;=</span> <span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n_y</span> <span class="o">&lt;=</span> <span class="n">box</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
    
    <span class="c1">#___________________________________________________________________________</span>
    <span class="k">return</span><span class="p">(</span><span class="n">n_inbox</span><span class="p">)</span></div>




<span class="c1"># ___INTERPOLATE FROM ELEMENTS TO VERTICES_____________________________________</span>
<span class="c1">#|                                                                             |</span>
<span class="c1">#|_____________________________________________________________________________|</span>
<div class="viewcode-block" id="grid_interp_e2n">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.grid_interp_e2n">[docs]</a>
<span class="k">def</span> <span class="nf">grid_interp_e2n</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">data_e</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --&gt; interpolate data from elements to vertices e.g velocity from elements to </span>
<span class="sd">    velocity on nodes</span>
<span class="sd">    </span>
<span class="sd">    Parameter:</span>
<span class="sd">    </span>
<span class="sd">        :mesh: fesom2 mesh object</span>
<span class="sd">        </span>
<span class="sd">        :data_e: np.array with datas on elements either 2d or 3d </span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">    </span>
<span class="sd">        :data_n: np.array with datas on vertices 2d or 3d</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#___________________________________________________________________________</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">compute_e_area</span><span class="p">()</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">compute_n_area</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">data_e</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># print(&#39;~~ &gt;-)))&gt; .oO A&#39;)</span>
        <span class="n">aux</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">e_area</span><span class="p">,</span><span class="n">mesh</span><span class="o">.</span><span class="n">e_area</span><span class="p">,</span><span class="n">mesh</span><span class="o">.</span><span class="n">e_area</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">aux</span>  <span class="o">=</span> <span class="n">aux</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">data_e</span><span class="p">,</span><span class="n">data_e</span><span class="p">,</span><span class="n">data_e</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="c1">#___________________________________________________________________________</span>
        <span class="c1"># single loop over self.e_i.flat is ~4 times faster than douple loop </span>
        <span class="c1"># over for i in range(3): ,for j in range(self.n2de):</span>
        <span class="n">data_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">n2dn</span><span class="p">,))</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">e_i</span><span class="o">.</span><span class="n">flat</span><span class="p">:</span>
            <span class="n">data_n</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">=</span><span class="n">data_n</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">aux</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
            <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span> <span class="c1"># count triangle index for aux_area[count] --&gt; aux_area =[n2de*3,]</span>
        <span class="k">del</span> <span class="n">aux</span><span class="p">,</span> <span class="n">count</span>
        <span class="c1">#with np.errstate(divide=&#39;ignore&#39;,invalid=&#39;ignore&#39;):</span>
        <span class="n">data_n</span><span class="o">=</span><span class="n">data_n</span><span class="o">/</span><span class="n">mesh</span><span class="o">.</span><span class="n">n_area</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">/</span><span class="mf">3.0</span>
        
    <span class="k">elif</span> <span class="n">data_e</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="c1">#print(&#39;~~ &gt;-)))&gt; .oO B&#39;)</span>
        <span class="n">nd</span>     <span class="o">=</span> <span class="n">data_e</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">data_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">n2dn</span><span class="p">,</span> <span class="n">nd</span><span class="p">))</span>
        <span class="n">data_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">n2dn</span><span class="p">,</span>   <span class="p">))</span>
        <span class="n">aux1</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">e_area</span><span class="p">,</span><span class="n">mesh</span><span class="o">.</span><span class="n">e_area</span><span class="p">,</span><span class="n">mesh</span><span class="o">.</span><span class="n">e_area</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="c1">#_______________________________________________________________________</span>
        <span class="k">def</span> <span class="nf">e2n_di</span><span class="p">(</span><span class="n">di</span><span class="p">,</span> <span class="n">data_e</span><span class="p">,</span> <span class="n">area_e</span><span class="p">,</span> <span class="n">e_i_flat</span><span class="p">,</span> <span class="n">n_iz</span><span class="p">):</span>
            <span class="n">data_exa</span> <span class="o">=</span> <span class="n">area_e</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">data_e</span><span class="p">[:,</span><span class="n">di</span><span class="p">],</span><span class="n">data_e</span><span class="p">[:,</span><span class="n">di</span><span class="p">],</span><span class="n">data_e</span><span class="p">[:,</span><span class="n">di</span><span class="p">]))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">suma</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_iz</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">data_n</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_iz</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1">#___________________________________________________________________</span>
            <span class="c1"># single loop over self.e_i.flat is ~4 times faster than douple loop </span>
            <span class="c1"># over for i in range(3): ,for j in range(self.n2de):</span>
            <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_i_flat</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">n_iz</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">&lt;</span><span class="n">di</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">data_n</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">=</span><span class="n">data_n</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">data_exa</span><span class="p">[</span> <span class="n">count</span><span class="p">]</span>
                <span class="n">data_a</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">=</span><span class="n">data_a</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">area_e</span><span class="p">[</span>   <span class="n">count</span><span class="p">]</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>    
                <span class="n">data_n</span><span class="o">=</span><span class="n">data_n</span><span class="o">/</span><span class="n">data_a</span>
            <span class="k">return</span><span class="p">(</span><span class="n">data_n</span><span class="p">)</span>
        
        
        <span class="c1">#t1 = clock.time()</span>
        <span class="c1">#for di in range(0,nd):</span>
            <span class="c1">#data_n[:, di] = e2n_di(di, data_e, aux1, mesh.e_i.flatten(), mesh.n_iz) </span>
        <span class="c1">#print(clock.time()-t1)</span>
        
        
        <span class="n">t1</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">20</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">e2n_di</span><span class="p">)(</span><span class="n">di</span><span class="p">,</span> <span class="n">data_e</span><span class="p">,</span> <span class="n">aux1</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">e_i</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">mesh</span><span class="o">.</span><span class="n">n_iz</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nd</span><span class="p">))</span>
        <span class="n">data_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">results</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; --&gt; elapsed time:&#39;</span><span class="p">,</span> <span class="n">clock</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t1</span><span class="p">)</span>
        
        <span class="c1">#t1 = clock.time()</span>
        <span class="c1">##_______________________________________________________________________</span>
        <span class="c1">#for ndi in range(0,nd):</span>
            <span class="c1">#aux  = aux1 * np.vstack((data_e[:,ndi],data_e[:,ndi],data_e[:,ndi])).transpose().flatten()</span>
            <span class="c1">##___________________________________________________________________</span>
            <span class="c1">## single loop over self.e_i.flat is ~4 times faster than douple loop </span>
            <span class="c1">## over for i in range(3): ,for j in range(self.n2de):</span>
            <span class="c1">#data_a[:] = 0</span>
            <span class="c1">#for count, idx in enumerate(mesh.e_i.flatten()):</span>
                <span class="c1">#if ndi&lt;=mesh.n_iz[idx]:</span>
                    <span class="c1">#data_n[idx, ndi]=data_n[idx, ndi] + aux[ count]</span>
                    <span class="c1">#data_a[idx     ]=data_a[idx     ] + aux1[count]</span>
            <span class="c1">#del aux</span>
            <span class="c1">##with np.errstate(divide=&#39;ignore&#39;,invalid=&#39;ignore&#39;):</span>
            <span class="c1">##data_n[:, ndi]=data_n[:, ndi]/mesh.n_area[ndi, :]/3.0</span>
            <span class="c1">#data_n[:, ndi]=data_n[:, ndi]/data_a</span>
        <span class="c1">#print(clock.time()-t1)    </span>
    <span class="c1">#___________________________________________________________________________</span>
    <span class="k">return</span><span class="p">(</span><span class="n">data_n</span><span class="p">)</span></div>




<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># ___COMPUTE BOUNDARY EDGES____________________________________________________</span>
<div class="viewcode-block" id="compute_boundary_edges">
<a class="viewcode-back" href="../../index.html#tripyview.sub_mesh.compute_boundary_edges">[docs]</a>
<span class="k">def</span> <span class="nf">compute_boundary_edges</span><span class="p">(</span><span class="n">e_i</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --&gt; compute edges that have only one adjacenbt triangle</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    </span>
<span class="sd">        :e_i:   np.array([n2de x 3]), elemental array</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    </span>
<span class="sd">        :bnde:</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># set boundary depth to zero</span>
    <span class="n">edge</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">e_i</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">e_i</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span> <span class="n">e_i</span><span class="p">[:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">edge</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
        
    <span class="c1">## python  sortrows algorythm --&gt; matlab equivalent</span>
    <span class="n">edge</span>    <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">edge</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">edge</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        
    <span class="n">idx</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span>
    <span class="n">idx</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">idx</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">]))),</span>\
                            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">]),</span><span class="n">idx</span><span class="p">)))</span>

    <span class="c1"># all edges that belong to boundary own jsut one triangle </span>
    <span class="n">bnde</span>    <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="n">idx</span><span class="o">==</span><span class="kc">False</span><span class="p">,:]</span>
    
    <span class="k">return</span><span class="p">(</span><span class="n">bnde</span><span class="p">)</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          
          <h3>Table of Contents</h3>
          
          <search role="search">
            <h3 style="margin-top: 1.5em;">Search</h3>
            <form class="search" action="../../search.html" method="get">
                <input type="text" name="q" />
                <input type="submit" value="Go" />
            </form>
          </search>

        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <div role="navigation" aria-label="Related">
            <a href="../../py-modindex.html" title="Python Module Index"
              >modules</a> |
            <a href="../../genindex.html" title="General Index"
              >index</a>
          </div>
          <div role="note" aria-label="source link">
          </div>
        </div>

        <div class="right">
          
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Patrick Scholz.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>